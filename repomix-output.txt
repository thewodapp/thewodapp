This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/db, src/server
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
src/
  db/
    migrations/
      meta/
        _journal.json
        0000_snapshot.json
        0001_snapshot.json
        0003_snapshot.json
        0004_snapshot.json
        0005_snapshot.json
        0006_snapshot.json
        0007_snapshot.json
        0008_snapshot.json
        0009_snapshot.json
        0010_snapshot.json
      0000_init.sql
      0001_add_emailVerified.sql
      0003_add_google_sso.sql
      0004_add_passkey_credentials.sql
      0005_add_opennext_cache_tables.sql
      0006_add_credit_billing_system.sql
      0007_add_update_counter_and_payment_intent_id.sql
      0008_add_multi_tenancy.sql
      0009_add_spicy_tables.sql
      0010_add_notes_to_sets.sql
    index.ts
    schema.ts
  server/
    logs.ts
    movements.ts
    tags.ts
    team-members.ts
    team-roles.ts
    teams.ts
    workout-results.ts
    workouts.ts

================================================================
Files
================================================================

================
File: src/db/migrations/meta/0000_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "8c82f116-7917-4e01-b7a0-5245bfeac328",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "tables": {
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "firstName": {
          "name": "firstName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "lastName": {
          "name": "lastName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "passwordHash": {
          "name": "passwordHash",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'user'"
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: src/db/migrations/meta/0001_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "bb5a14fa-b59a-45b0-85b6-f8c0a04b7717",
  "prevId": "8c82f116-7917-4e01-b7a0-5245bfeac328",
  "tables": {
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "firstName": {
          "name": "firstName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "lastName": {
          "name": "lastName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "passwordHash": {
          "name": "passwordHash",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'user'"
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: src/db/migrations/meta/0003_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "30c7c67d-947f-45a4-8e2d-dc16a090be13",
  "prevId": "bb5a14fa-b59a-45b0-85b6-f8c0a04b7717",
  "tables": {
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "firstName": {
          "name": "firstName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "lastName": {
          "name": "lastName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "passwordHash": {
          "name": "passwordHash",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'user'"
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "signUpIpAddress": {
          "name": "signUpIpAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "googleAccountId": {
          "name": "googleAccountId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatar": {
          "name": "avatar",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        },
        "email_idx": {
          "name": "email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "google_account_id_idx": {
          "name": "google_account_id_idx",
          "columns": [
            "googleAccountId"
          ],
          "isUnique": false
        },
        "role_idx": {
          "name": "role_idx",
          "columns": [
            "role"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: src/db/migrations/meta/0004_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "81b88d85-a1d8-4ce9-b10f-26cd5fb6db6c",
  "prevId": "30c7c67d-947f-45a4-8e2d-dc16a090be13",
  "tables": {
    "passkey_credential": {
      "name": "passkey_credential",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialId": {
          "name": "credentialId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialPublicKey": {
          "name": "credentialPublicKey",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "counter": {
          "name": "counter",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "transports": {
          "name": "transports",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "aaguid": {
          "name": "aaguid",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "userAgent": {
          "name": "userAgent",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "ipAddress": {
          "name": "ipAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "passkey_credential_credentialId_unique": {
          "name": "passkey_credential_credentialId_unique",
          "columns": [
            "credentialId"
          ],
          "isUnique": true
        },
        "user_id_idx": {
          "name": "user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credential_id_idx": {
          "name": "credential_id_idx",
          "columns": [
            "credentialId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "passkey_credential_userId_user_id_fk": {
          "name": "passkey_credential_userId_user_id_fk",
          "tableFrom": "passkey_credential",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "firstName": {
          "name": "firstName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "lastName": {
          "name": "lastName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "passwordHash": {
          "name": "passwordHash",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'user'"
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "signUpIpAddress": {
          "name": "signUpIpAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "googleAccountId": {
          "name": "googleAccountId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatar": {
          "name": "avatar",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        },
        "email_idx": {
          "name": "email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "google_account_id_idx": {
          "name": "google_account_id_idx",
          "columns": [
            "googleAccountId"
          ],
          "isUnique": false
        },
        "role_idx": {
          "name": "role_idx",
          "columns": [
            "role"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: src/db/migrations/meta/0005_snapshot.json
================
{
  "id": "464e607f-4645-45da-84e0-78622259cf8d",
  "prevId": "81b88d85-a1d8-4ce9-b10f-26cd5fb6db6c",
  "version": "6",
  "dialect": "sqlite",
  "tables": {
    "passkey_credential": {
      "name": "passkey_credential",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialId": {
          "name": "credentialId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialPublicKey": {
          "name": "credentialPublicKey",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "counter": {
          "name": "counter",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "transports": {
          "name": "transports",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "aaguid": {
          "name": "aaguid",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "userAgent": {
          "name": "userAgent",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "ipAddress": {
          "name": "ipAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "passkey_credential_credentialId_unique": {
          "name": "passkey_credential_credentialId_unique",
          "columns": [
            "credentialId"
          ],
          "isUnique": true
        },
        "user_id_idx": {
          "name": "user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credential_id_idx": {
          "name": "credential_id_idx",
          "columns": [
            "credentialId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "passkey_credential_userId_user_id_fk": {
          "name": "passkey_credential_userId_user_id_fk",
          "tableFrom": "passkey_credential",
          "columnsFrom": [
            "userId"
          ],
          "tableTo": "user",
          "columnsTo": [
            "id"
          ],
          "onUpdate": "no action",
          "onDelete": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "firstName": {
          "name": "firstName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "lastName": {
          "name": "lastName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "passwordHash": {
          "name": "passwordHash",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'user'"
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "signUpIpAddress": {
          "name": "signUpIpAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "googleAccountId": {
          "name": "googleAccountId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatar": {
          "name": "avatar",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        },
        "email_idx": {
          "name": "email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "google_account_id_idx": {
          "name": "google_account_id_idx",
          "columns": [
            "googleAccountId"
          ],
          "isUnique": false
        },
        "role_idx": {
          "name": "role_idx",
          "columns": [
            "role"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: src/db/migrations/meta/0006_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "250fbde8-5e23-48b6-b4bc-3254a652a8d2",
  "prevId": "464e607f-4645-45da-84e0-78622259cf8d",
  "tables": {
    "credit_transaction": {
      "name": "credit_transaction",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "amount": {
          "name": "amount",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "remainingAmount": {
          "name": "remainingAmount",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "expirationDate": {
          "name": "expirationDate",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expirationDateProcessedAt": {
          "name": "expirationDateProcessedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "credit_transaction_user_id_idx": {
          "name": "credit_transaction_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credit_transaction_type_idx": {
          "name": "credit_transaction_type_idx",
          "columns": [
            "type"
          ],
          "isUnique": false
        },
        "credit_transaction_created_at_idx": {
          "name": "credit_transaction_created_at_idx",
          "columns": [
            "createdAt"
          ],
          "isUnique": false
        },
        "credit_transaction_expiration_date_idx": {
          "name": "credit_transaction_expiration_date_idx",
          "columns": [
            "expirationDate"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "credit_transaction_userId_user_id_fk": {
          "name": "credit_transaction_userId_user_id_fk",
          "tableFrom": "credit_transaction",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "passkey_credential": {
      "name": "passkey_credential",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialId": {
          "name": "credentialId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialPublicKey": {
          "name": "credentialPublicKey",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "counter": {
          "name": "counter",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "transports": {
          "name": "transports",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "aaguid": {
          "name": "aaguid",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "userAgent": {
          "name": "userAgent",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "ipAddress": {
          "name": "ipAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "passkey_credential_credentialId_unique": {
          "name": "passkey_credential_credentialId_unique",
          "columns": [
            "credentialId"
          ],
          "isUnique": true
        },
        "user_id_idx": {
          "name": "user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credential_id_idx": {
          "name": "credential_id_idx",
          "columns": [
            "credentialId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "passkey_credential_userId_user_id_fk": {
          "name": "passkey_credential_userId_user_id_fk",
          "tableFrom": "passkey_credential",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "purchased_item": {
      "name": "purchased_item",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "itemType": {
          "name": "itemType",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "itemId": {
          "name": "itemId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "purchasedAt": {
          "name": "purchasedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "purchased_item_user_id_idx": {
          "name": "purchased_item_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "purchased_item_type_idx": {
          "name": "purchased_item_type_idx",
          "columns": [
            "itemType"
          ],
          "isUnique": false
        },
        "purchased_item_user_item_idx": {
          "name": "purchased_item_user_item_idx",
          "columns": [
            "userId",
            "itemType",
            "itemId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "purchased_item_userId_user_id_fk": {
          "name": "purchased_item_userId_user_id_fk",
          "tableFrom": "purchased_item",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "firstName": {
          "name": "firstName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "lastName": {
          "name": "lastName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "passwordHash": {
          "name": "passwordHash",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'user'"
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "signUpIpAddress": {
          "name": "signUpIpAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "googleAccountId": {
          "name": "googleAccountId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatar": {
          "name": "avatar",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "currentCredits": {
          "name": "currentCredits",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lastCreditRefreshAt": {
          "name": "lastCreditRefreshAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        },
        "email_idx": {
          "name": "email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "google_account_id_idx": {
          "name": "google_account_id_idx",
          "columns": [
            "googleAccountId"
          ],
          "isUnique": false
        },
        "role_idx": {
          "name": "role_idx",
          "columns": [
            "role"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: src/db/migrations/meta/0007_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "7a370256-466f-4518-8428-d3b9e7159cec",
  "prevId": "250fbde8-5e23-48b6-b4bc-3254a652a8d2",
  "tables": {
    "credit_transaction": {
      "name": "credit_transaction",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "amount": {
          "name": "amount",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "remainingAmount": {
          "name": "remainingAmount",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "expirationDate": {
          "name": "expirationDate",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expirationDateProcessedAt": {
          "name": "expirationDateProcessedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "paymentIntentId": {
          "name": "paymentIntentId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "credit_transaction_user_id_idx": {
          "name": "credit_transaction_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credit_transaction_type_idx": {
          "name": "credit_transaction_type_idx",
          "columns": [
            "type"
          ],
          "isUnique": false
        },
        "credit_transaction_created_at_idx": {
          "name": "credit_transaction_created_at_idx",
          "columns": [
            "createdAt"
          ],
          "isUnique": false
        },
        "credit_transaction_expiration_date_idx": {
          "name": "credit_transaction_expiration_date_idx",
          "columns": [
            "expirationDate"
          ],
          "isUnique": false
        },
        "credit_transaction_payment_intent_id_idx": {
          "name": "credit_transaction_payment_intent_id_idx",
          "columns": [
            "paymentIntentId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "credit_transaction_userId_user_id_fk": {
          "name": "credit_transaction_userId_user_id_fk",
          "tableFrom": "credit_transaction",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "passkey_credential": {
      "name": "passkey_credential",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialId": {
          "name": "credentialId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialPublicKey": {
          "name": "credentialPublicKey",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "counter": {
          "name": "counter",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "transports": {
          "name": "transports",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "aaguid": {
          "name": "aaguid",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "userAgent": {
          "name": "userAgent",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "ipAddress": {
          "name": "ipAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "passkey_credential_credentialId_unique": {
          "name": "passkey_credential_credentialId_unique",
          "columns": [
            "credentialId"
          ],
          "isUnique": true
        },
        "user_id_idx": {
          "name": "user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credential_id_idx": {
          "name": "credential_id_idx",
          "columns": [
            "credentialId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "passkey_credential_userId_user_id_fk": {
          "name": "passkey_credential_userId_user_id_fk",
          "tableFrom": "passkey_credential",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "purchased_item": {
      "name": "purchased_item",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "itemType": {
          "name": "itemType",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "itemId": {
          "name": "itemId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "purchasedAt": {
          "name": "purchasedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "purchased_item_user_id_idx": {
          "name": "purchased_item_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "purchased_item_type_idx": {
          "name": "purchased_item_type_idx",
          "columns": [
            "itemType"
          ],
          "isUnique": false
        },
        "purchased_item_user_item_idx": {
          "name": "purchased_item_user_item_idx",
          "columns": [
            "userId",
            "itemType",
            "itemId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "purchased_item_userId_user_id_fk": {
          "name": "purchased_item_userId_user_id_fk",
          "tableFrom": "purchased_item",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "firstName": {
          "name": "firstName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "lastName": {
          "name": "lastName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "passwordHash": {
          "name": "passwordHash",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'user'"
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "signUpIpAddress": {
          "name": "signUpIpAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "googleAccountId": {
          "name": "googleAccountId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatar": {
          "name": "avatar",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "currentCredits": {
          "name": "currentCredits",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lastCreditRefreshAt": {
          "name": "lastCreditRefreshAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        },
        "email_idx": {
          "name": "email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "google_account_id_idx": {
          "name": "google_account_id_idx",
          "columns": [
            "googleAccountId"
          ],
          "isUnique": false
        },
        "role_idx": {
          "name": "role_idx",
          "columns": [
            "role"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: src/db/migrations/meta/0008_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "59579936-107a-4565-acf3-10fe5a0984f9",
  "prevId": "7a370256-466f-4518-8428-d3b9e7159cec",
  "tables": {
    "credit_transaction": {
      "name": "credit_transaction",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "amount": {
          "name": "amount",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "remainingAmount": {
          "name": "remainingAmount",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "expirationDate": {
          "name": "expirationDate",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expirationDateProcessedAt": {
          "name": "expirationDateProcessedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "paymentIntentId": {
          "name": "paymentIntentId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "credit_transaction_user_id_idx": {
          "name": "credit_transaction_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credit_transaction_type_idx": {
          "name": "credit_transaction_type_idx",
          "columns": [
            "type"
          ],
          "isUnique": false
        },
        "credit_transaction_created_at_idx": {
          "name": "credit_transaction_created_at_idx",
          "columns": [
            "createdAt"
          ],
          "isUnique": false
        },
        "credit_transaction_expiration_date_idx": {
          "name": "credit_transaction_expiration_date_idx",
          "columns": [
            "expirationDate"
          ],
          "isUnique": false
        },
        "credit_transaction_payment_intent_id_idx": {
          "name": "credit_transaction_payment_intent_id_idx",
          "columns": [
            "paymentIntentId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "credit_transaction_userId_user_id_fk": {
          "name": "credit_transaction_userId_user_id_fk",
          "tableFrom": "credit_transaction",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "passkey_credential": {
      "name": "passkey_credential",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialId": {
          "name": "credentialId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialPublicKey": {
          "name": "credentialPublicKey",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "counter": {
          "name": "counter",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "transports": {
          "name": "transports",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "aaguid": {
          "name": "aaguid",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "userAgent": {
          "name": "userAgent",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "ipAddress": {
          "name": "ipAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "passkey_credential_credentialId_unique": {
          "name": "passkey_credential_credentialId_unique",
          "columns": [
            "credentialId"
          ],
          "isUnique": true
        },
        "user_id_idx": {
          "name": "user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credential_id_idx": {
          "name": "credential_id_idx",
          "columns": [
            "credentialId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "passkey_credential_userId_user_id_fk": {
          "name": "passkey_credential_userId_user_id_fk",
          "tableFrom": "passkey_credential",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "purchased_item": {
      "name": "purchased_item",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "itemType": {
          "name": "itemType",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "itemId": {
          "name": "itemId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "purchasedAt": {
          "name": "purchasedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "purchased_item_user_id_idx": {
          "name": "purchased_item_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "purchased_item_type_idx": {
          "name": "purchased_item_type_idx",
          "columns": [
            "itemType"
          ],
          "isUnique": false
        },
        "purchased_item_user_item_idx": {
          "name": "purchased_item_user_item_idx",
          "columns": [
            "userId",
            "itemType",
            "itemId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "purchased_item_userId_user_id_fk": {
          "name": "purchased_item_userId_user_id_fk",
          "tableFrom": "purchased_item",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team_invitation": {
      "name": "team_invitation",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "teamId": {
          "name": "teamId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "roleId": {
          "name": "roleId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "isSystemRole": {
          "name": "isSystemRole",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "token": {
          "name": "token",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "invitedBy": {
          "name": "invitedBy",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "expiresAt": {
          "name": "expiresAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "acceptedAt": {
          "name": "acceptedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "acceptedBy": {
          "name": "acceptedBy",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "team_invitation_token_unique": {
          "name": "team_invitation_token_unique",
          "columns": [
            "token"
          ],
          "isUnique": true
        },
        "team_invitation_team_id_idx": {
          "name": "team_invitation_team_id_idx",
          "columns": [
            "teamId"
          ],
          "isUnique": false
        },
        "team_invitation_email_idx": {
          "name": "team_invitation_email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "team_invitation_token_idx": {
          "name": "team_invitation_token_idx",
          "columns": [
            "token"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "team_invitation_teamId_team_id_fk": {
          "name": "team_invitation_teamId_team_id_fk",
          "tableFrom": "team_invitation",
          "tableTo": "team",
          "columnsFrom": [
            "teamId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_invitation_invitedBy_user_id_fk": {
          "name": "team_invitation_invitedBy_user_id_fk",
          "tableFrom": "team_invitation",
          "tableTo": "user",
          "columnsFrom": [
            "invitedBy"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_invitation_acceptedBy_user_id_fk": {
          "name": "team_invitation_acceptedBy_user_id_fk",
          "tableFrom": "team_invitation",
          "tableTo": "user",
          "columnsFrom": [
            "acceptedBy"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team_membership": {
      "name": "team_membership",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "teamId": {
          "name": "teamId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "roleId": {
          "name": "roleId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "isSystemRole": {
          "name": "isSystemRole",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "invitedBy": {
          "name": "invitedBy",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "invitedAt": {
          "name": "invitedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "joinedAt": {
          "name": "joinedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expiresAt": {
          "name": "expiresAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "isActive": {
          "name": "isActive",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        }
      },
      "indexes": {
        "team_membership_team_id_idx": {
          "name": "team_membership_team_id_idx",
          "columns": [
            "teamId"
          ],
          "isUnique": false
        },
        "team_membership_user_id_idx": {
          "name": "team_membership_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "team_membership_unique_idx": {
          "name": "team_membership_unique_idx",
          "columns": [
            "teamId",
            "userId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "team_membership_teamId_team_id_fk": {
          "name": "team_membership_teamId_team_id_fk",
          "tableFrom": "team_membership",
          "tableTo": "team",
          "columnsFrom": [
            "teamId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_membership_userId_user_id_fk": {
          "name": "team_membership_userId_user_id_fk",
          "tableFrom": "team_membership",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_membership_invitedBy_user_id_fk": {
          "name": "team_membership_invitedBy_user_id_fk",
          "tableFrom": "team_membership",
          "tableTo": "user",
          "columnsFrom": [
            "invitedBy"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team_role": {
      "name": "team_role",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "teamId": {
          "name": "teamId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(1000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "permissions": {
          "name": "permissions",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "metadata": {
          "name": "metadata",
          "type": "text(5000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "isEditable": {
          "name": "isEditable",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        }
      },
      "indexes": {
        "team_role_team_id_idx": {
          "name": "team_role_team_id_idx",
          "columns": [
            "teamId"
          ],
          "isUnique": false
        },
        "team_role_name_unique_idx": {
          "name": "team_role_name_unique_idx",
          "columns": [
            "teamId",
            "name"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "team_role_teamId_team_id_fk": {
          "name": "team_role_teamId_team_id_fk",
          "tableFrom": "team_role",
          "tableTo": "team",
          "columnsFrom": [
            "teamId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team": {
      "name": "team",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "slug": {
          "name": "slug",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(1000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatarUrl": {
          "name": "avatarUrl",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "settings": {
          "name": "settings",
          "type": "text(10000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "billingEmail": {
          "name": "billingEmail",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "planId": {
          "name": "planId",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "planExpiresAt": {
          "name": "planExpiresAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "creditBalance": {
          "name": "creditBalance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        }
      },
      "indexes": {
        "team_slug_unique": {
          "name": "team_slug_unique",
          "columns": [
            "slug"
          ],
          "isUnique": true
        },
        "team_slug_idx": {
          "name": "team_slug_idx",
          "columns": [
            "slug"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "firstName": {
          "name": "firstName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "lastName": {
          "name": "lastName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "passwordHash": {
          "name": "passwordHash",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'user'"
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "signUpIpAddress": {
          "name": "signUpIpAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "googleAccountId": {
          "name": "googleAccountId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatar": {
          "name": "avatar",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "currentCredits": {
          "name": "currentCredits",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lastCreditRefreshAt": {
          "name": "lastCreditRefreshAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        },
        "email_idx": {
          "name": "email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "google_account_id_idx": {
          "name": "google_account_id_idx",
          "columns": [
            "googleAccountId"
          ],
          "isUnique": false
        },
        "role_idx": {
          "name": "role_idx",
          "columns": [
            "role"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: src/db/migrations/meta/0009_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "f73d9bec-0749-430d-bf7c-8aa46a2ba96b",
  "prevId": "59579936-107a-4565-acf3-10fe5a0984f9",
  "tables": {
    "credit_transaction": {
      "name": "credit_transaction",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "amount": {
          "name": "amount",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "remainingAmount": {
          "name": "remainingAmount",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "expirationDate": {
          "name": "expirationDate",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expirationDateProcessedAt": {
          "name": "expirationDateProcessedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "paymentIntentId": {
          "name": "paymentIntentId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "credit_transaction_user_id_idx": {
          "name": "credit_transaction_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credit_transaction_type_idx": {
          "name": "credit_transaction_type_idx",
          "columns": [
            "type"
          ],
          "isUnique": false
        },
        "credit_transaction_created_at_idx": {
          "name": "credit_transaction_created_at_idx",
          "columns": [
            "createdAt"
          ],
          "isUnique": false
        },
        "credit_transaction_expiration_date_idx": {
          "name": "credit_transaction_expiration_date_idx",
          "columns": [
            "expirationDate"
          ],
          "isUnique": false
        },
        "credit_transaction_payment_intent_id_idx": {
          "name": "credit_transaction_payment_intent_id_idx",
          "columns": [
            "paymentIntentId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "credit_transaction_userId_user_id_fk": {
          "name": "credit_transaction_userId_user_id_fk",
          "tableFrom": "credit_transaction",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "movements": {
      "name": "movements",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "passkey_credential": {
      "name": "passkey_credential",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialId": {
          "name": "credentialId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialPublicKey": {
          "name": "credentialPublicKey",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "counter": {
          "name": "counter",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "transports": {
          "name": "transports",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "aaguid": {
          "name": "aaguid",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "userAgent": {
          "name": "userAgent",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "ipAddress": {
          "name": "ipAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "passkey_credential_credentialId_unique": {
          "name": "passkey_credential_credentialId_unique",
          "columns": [
            "credentialId"
          ],
          "isUnique": true
        },
        "user_id_idx": {
          "name": "user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credential_id_idx": {
          "name": "credential_id_idx",
          "columns": [
            "credentialId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "passkey_credential_userId_user_id_fk": {
          "name": "passkey_credential_userId_user_id_fk",
          "tableFrom": "passkey_credential",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "purchased_item": {
      "name": "purchased_item",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "itemType": {
          "name": "itemType",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "itemId": {
          "name": "itemId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "purchasedAt": {
          "name": "purchasedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "purchased_item_user_id_idx": {
          "name": "purchased_item_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "purchased_item_type_idx": {
          "name": "purchased_item_type_idx",
          "columns": [
            "itemType"
          ],
          "isUnique": false
        },
        "purchased_item_user_item_idx": {
          "name": "purchased_item_user_item_idx",
          "columns": [
            "userId",
            "itemType",
            "itemId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "purchased_item_userId_user_id_fk": {
          "name": "purchased_item_userId_user_id_fk",
          "tableFrom": "purchased_item",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "results": {
      "name": "results",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "date": {
          "name": "date",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "workout_id": {
          "name": "workout_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "notes": {
          "name": "notes",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "scale": {
          "name": "scale",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "wod_score": {
          "name": "wod_score",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "set_count": {
          "name": "set_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "distance": {
          "name": "distance",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "time": {
          "name": "time",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "results_user_id_user_id_fk": {
          "name": "results_user_id_user_id_fk",
          "tableFrom": "results",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "results_workout_id_workouts_id_fk": {
          "name": "results_workout_id_workouts_id_fk",
          "tableFrom": "results",
          "tableTo": "workouts",
          "columnsFrom": [
            "workout_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "sets": {
      "name": "sets",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "result_id": {
          "name": "result_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "set_number": {
          "name": "set_number",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "reps": {
          "name": "reps",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "weight": {
          "name": "weight",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "status": {
          "name": "status",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "distance": {
          "name": "distance",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "time": {
          "name": "time",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "score": {
          "name": "score",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "sets_result_id_results_id_fk": {
          "name": "sets_result_id_results_id_fk",
          "tableFrom": "sets",
          "tableTo": "results",
          "columnsFrom": [
            "result_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "spicy_tags": {
      "name": "spicy_tags",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "spicy_tags_name_unique": {
          "name": "spicy_tags_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team_invitation": {
      "name": "team_invitation",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "teamId": {
          "name": "teamId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "roleId": {
          "name": "roleId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "isSystemRole": {
          "name": "isSystemRole",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "token": {
          "name": "token",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "invitedBy": {
          "name": "invitedBy",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "expiresAt": {
          "name": "expiresAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "acceptedAt": {
          "name": "acceptedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "acceptedBy": {
          "name": "acceptedBy",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "team_invitation_token_unique": {
          "name": "team_invitation_token_unique",
          "columns": [
            "token"
          ],
          "isUnique": true
        },
        "team_invitation_team_id_idx": {
          "name": "team_invitation_team_id_idx",
          "columns": [
            "teamId"
          ],
          "isUnique": false
        },
        "team_invitation_email_idx": {
          "name": "team_invitation_email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "team_invitation_token_idx": {
          "name": "team_invitation_token_idx",
          "columns": [
            "token"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "team_invitation_teamId_team_id_fk": {
          "name": "team_invitation_teamId_team_id_fk",
          "tableFrom": "team_invitation",
          "tableTo": "team",
          "columnsFrom": [
            "teamId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_invitation_invitedBy_user_id_fk": {
          "name": "team_invitation_invitedBy_user_id_fk",
          "tableFrom": "team_invitation",
          "tableTo": "user",
          "columnsFrom": [
            "invitedBy"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_invitation_acceptedBy_user_id_fk": {
          "name": "team_invitation_acceptedBy_user_id_fk",
          "tableFrom": "team_invitation",
          "tableTo": "user",
          "columnsFrom": [
            "acceptedBy"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team_membership": {
      "name": "team_membership",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "teamId": {
          "name": "teamId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "roleId": {
          "name": "roleId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "isSystemRole": {
          "name": "isSystemRole",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "invitedBy": {
          "name": "invitedBy",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "invitedAt": {
          "name": "invitedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "joinedAt": {
          "name": "joinedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expiresAt": {
          "name": "expiresAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "isActive": {
          "name": "isActive",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        }
      },
      "indexes": {
        "team_membership_team_id_idx": {
          "name": "team_membership_team_id_idx",
          "columns": [
            "teamId"
          ],
          "isUnique": false
        },
        "team_membership_user_id_idx": {
          "name": "team_membership_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "team_membership_unique_idx": {
          "name": "team_membership_unique_idx",
          "columns": [
            "teamId",
            "userId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "team_membership_teamId_team_id_fk": {
          "name": "team_membership_teamId_team_id_fk",
          "tableFrom": "team_membership",
          "tableTo": "team",
          "columnsFrom": [
            "teamId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_membership_userId_user_id_fk": {
          "name": "team_membership_userId_user_id_fk",
          "tableFrom": "team_membership",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_membership_invitedBy_user_id_fk": {
          "name": "team_membership_invitedBy_user_id_fk",
          "tableFrom": "team_membership",
          "tableTo": "user",
          "columnsFrom": [
            "invitedBy"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team_role": {
      "name": "team_role",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "teamId": {
          "name": "teamId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(1000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "permissions": {
          "name": "permissions",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "metadata": {
          "name": "metadata",
          "type": "text(5000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "isEditable": {
          "name": "isEditable",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        }
      },
      "indexes": {
        "team_role_team_id_idx": {
          "name": "team_role_team_id_idx",
          "columns": [
            "teamId"
          ],
          "isUnique": false
        },
        "team_role_name_unique_idx": {
          "name": "team_role_name_unique_idx",
          "columns": [
            "teamId",
            "name"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "team_role_teamId_team_id_fk": {
          "name": "team_role_teamId_team_id_fk",
          "tableFrom": "team_role",
          "tableTo": "team",
          "columnsFrom": [
            "teamId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team": {
      "name": "team",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "slug": {
          "name": "slug",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(1000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatarUrl": {
          "name": "avatarUrl",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "settings": {
          "name": "settings",
          "type": "text(10000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "billingEmail": {
          "name": "billingEmail",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "planId": {
          "name": "planId",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "planExpiresAt": {
          "name": "planExpiresAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "creditBalance": {
          "name": "creditBalance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        }
      },
      "indexes": {
        "team_slug_unique": {
          "name": "team_slug_unique",
          "columns": [
            "slug"
          ],
          "isUnique": true
        },
        "team_slug_idx": {
          "name": "team_slug_idx",
          "columns": [
            "slug"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "firstName": {
          "name": "firstName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "lastName": {
          "name": "lastName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "passwordHash": {
          "name": "passwordHash",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'user'"
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "signUpIpAddress": {
          "name": "signUpIpAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "googleAccountId": {
          "name": "googleAccountId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatar": {
          "name": "avatar",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "currentCredits": {
          "name": "currentCredits",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lastCreditRefreshAt": {
          "name": "lastCreditRefreshAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        },
        "email_idx": {
          "name": "email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "google_account_id_idx": {
          "name": "google_account_id_idx",
          "columns": [
            "googleAccountId"
          ],
          "isUnique": false
        },
        "role_idx": {
          "name": "role_idx",
          "columns": [
            "role"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "workout_movements": {
      "name": "workout_movements",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "workout_id": {
          "name": "workout_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "movement_id": {
          "name": "movement_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "workout_movements_workout_id_workouts_id_fk": {
          "name": "workout_movements_workout_id_workouts_id_fk",
          "tableFrom": "workout_movements",
          "tableTo": "workouts",
          "columnsFrom": [
            "workout_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "workout_movements_movement_id_movements_id_fk": {
          "name": "workout_movements_movement_id_movements_id_fk",
          "tableFrom": "workout_movements",
          "tableTo": "movements",
          "columnsFrom": [
            "movement_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "workout_tags": {
      "name": "workout_tags",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "workout_id": {
          "name": "workout_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "tag_id": {
          "name": "tag_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "workout_tags_workout_id_workouts_id_fk": {
          "name": "workout_tags_workout_id_workouts_id_fk",
          "tableFrom": "workout_tags",
          "tableTo": "workouts",
          "columnsFrom": [
            "workout_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "workout_tags_tag_id_spicy_tags_id_fk": {
          "name": "workout_tags_tag_id_spicy_tags_id_fk",
          "tableFrom": "workout_tags",
          "tableTo": "spicy_tags",
          "columnsFrom": [
            "tag_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "workouts": {
      "name": "workouts",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'private'"
        },
        "scheme": {
          "name": "scheme",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "reps_per_round": {
          "name": "reps_per_round",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "rounds_to_score": {
          "name": "rounds_to_score",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 1
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "sugar_id": {
          "name": "sugar_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "tiebreak_scheme": {
          "name": "tiebreak_scheme",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "secondary_scheme": {
          "name": "secondary_scheme",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "workouts_user_id_user_id_fk": {
          "name": "workouts_user_id_user_id_fk",
          "tableFrom": "workouts",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: src/db/migrations/meta/0010_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "e563dfb4-490f-49bb-acf8-5b5d3513683a",
  "prevId": "f73d9bec-0749-430d-bf7c-8aa46a2ba96b",
  "tables": {
    "credit_transaction": {
      "name": "credit_transaction",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "amount": {
          "name": "amount",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "remainingAmount": {
          "name": "remainingAmount",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "expirationDate": {
          "name": "expirationDate",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expirationDateProcessedAt": {
          "name": "expirationDateProcessedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "paymentIntentId": {
          "name": "paymentIntentId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "credit_transaction_user_id_idx": {
          "name": "credit_transaction_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credit_transaction_type_idx": {
          "name": "credit_transaction_type_idx",
          "columns": [
            "type"
          ],
          "isUnique": false
        },
        "credit_transaction_created_at_idx": {
          "name": "credit_transaction_created_at_idx",
          "columns": [
            "createdAt"
          ],
          "isUnique": false
        },
        "credit_transaction_expiration_date_idx": {
          "name": "credit_transaction_expiration_date_idx",
          "columns": [
            "expirationDate"
          ],
          "isUnique": false
        },
        "credit_transaction_payment_intent_id_idx": {
          "name": "credit_transaction_payment_intent_id_idx",
          "columns": [
            "paymentIntentId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "credit_transaction_userId_user_id_fk": {
          "name": "credit_transaction_userId_user_id_fk",
          "tableFrom": "credit_transaction",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "movements": {
      "name": "movements",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "passkey_credential": {
      "name": "passkey_credential",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialId": {
          "name": "credentialId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "credentialPublicKey": {
          "name": "credentialPublicKey",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "counter": {
          "name": "counter",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "transports": {
          "name": "transports",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "aaguid": {
          "name": "aaguid",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "userAgent": {
          "name": "userAgent",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "ipAddress": {
          "name": "ipAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "passkey_credential_credentialId_unique": {
          "name": "passkey_credential_credentialId_unique",
          "columns": [
            "credentialId"
          ],
          "isUnique": true
        },
        "user_id_idx": {
          "name": "user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "credential_id_idx": {
          "name": "credential_id_idx",
          "columns": [
            "credentialId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "passkey_credential_userId_user_id_fk": {
          "name": "passkey_credential_userId_user_id_fk",
          "tableFrom": "passkey_credential",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "purchased_item": {
      "name": "purchased_item",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "itemType": {
          "name": "itemType",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "itemId": {
          "name": "itemId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "purchasedAt": {
          "name": "purchasedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "purchased_item_user_id_idx": {
          "name": "purchased_item_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "purchased_item_type_idx": {
          "name": "purchased_item_type_idx",
          "columns": [
            "itemType"
          ],
          "isUnique": false
        },
        "purchased_item_user_item_idx": {
          "name": "purchased_item_user_item_idx",
          "columns": [
            "userId",
            "itemType",
            "itemId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "purchased_item_userId_user_id_fk": {
          "name": "purchased_item_userId_user_id_fk",
          "tableFrom": "purchased_item",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "results": {
      "name": "results",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "date": {
          "name": "date",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "workout_id": {
          "name": "workout_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "type": {
          "name": "type",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "notes": {
          "name": "notes",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "scale": {
          "name": "scale",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "wod_score": {
          "name": "wod_score",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "set_count": {
          "name": "set_count",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "distance": {
          "name": "distance",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "time": {
          "name": "time",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "results_user_id_user_id_fk": {
          "name": "results_user_id_user_id_fk",
          "tableFrom": "results",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "results_workout_id_workouts_id_fk": {
          "name": "results_workout_id_workouts_id_fk",
          "tableFrom": "results",
          "tableTo": "workouts",
          "columnsFrom": [
            "workout_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "sets": {
      "name": "sets",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "result_id": {
          "name": "result_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "set_number": {
          "name": "set_number",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "notes": {
          "name": "notes",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "reps": {
          "name": "reps",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "weight": {
          "name": "weight",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "status": {
          "name": "status",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "distance": {
          "name": "distance",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "time": {
          "name": "time",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "score": {
          "name": "score",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "sets_result_id_results_id_fk": {
          "name": "sets_result_id_results_id_fk",
          "tableFrom": "sets",
          "tableTo": "results",
          "columnsFrom": [
            "result_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "spicy_tags": {
      "name": "spicy_tags",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "spicy_tags_name_unique": {
          "name": "spicy_tags_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team_invitation": {
      "name": "team_invitation",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "teamId": {
          "name": "teamId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "roleId": {
          "name": "roleId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "isSystemRole": {
          "name": "isSystemRole",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "token": {
          "name": "token",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "invitedBy": {
          "name": "invitedBy",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "expiresAt": {
          "name": "expiresAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "acceptedAt": {
          "name": "acceptedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "acceptedBy": {
          "name": "acceptedBy",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "team_invitation_token_unique": {
          "name": "team_invitation_token_unique",
          "columns": [
            "token"
          ],
          "isUnique": true
        },
        "team_invitation_team_id_idx": {
          "name": "team_invitation_team_id_idx",
          "columns": [
            "teamId"
          ],
          "isUnique": false
        },
        "team_invitation_email_idx": {
          "name": "team_invitation_email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "team_invitation_token_idx": {
          "name": "team_invitation_token_idx",
          "columns": [
            "token"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "team_invitation_teamId_team_id_fk": {
          "name": "team_invitation_teamId_team_id_fk",
          "tableFrom": "team_invitation",
          "tableTo": "team",
          "columnsFrom": [
            "teamId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_invitation_invitedBy_user_id_fk": {
          "name": "team_invitation_invitedBy_user_id_fk",
          "tableFrom": "team_invitation",
          "tableTo": "user",
          "columnsFrom": [
            "invitedBy"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_invitation_acceptedBy_user_id_fk": {
          "name": "team_invitation_acceptedBy_user_id_fk",
          "tableFrom": "team_invitation",
          "tableTo": "user",
          "columnsFrom": [
            "acceptedBy"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team_membership": {
      "name": "team_membership",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "teamId": {
          "name": "teamId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "userId": {
          "name": "userId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "roleId": {
          "name": "roleId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "isSystemRole": {
          "name": "isSystemRole",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "invitedBy": {
          "name": "invitedBy",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "invitedAt": {
          "name": "invitedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "joinedAt": {
          "name": "joinedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "expiresAt": {
          "name": "expiresAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "isActive": {
          "name": "isActive",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        }
      },
      "indexes": {
        "team_membership_team_id_idx": {
          "name": "team_membership_team_id_idx",
          "columns": [
            "teamId"
          ],
          "isUnique": false
        },
        "team_membership_user_id_idx": {
          "name": "team_membership_user_id_idx",
          "columns": [
            "userId"
          ],
          "isUnique": false
        },
        "team_membership_unique_idx": {
          "name": "team_membership_unique_idx",
          "columns": [
            "teamId",
            "userId"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "team_membership_teamId_team_id_fk": {
          "name": "team_membership_teamId_team_id_fk",
          "tableFrom": "team_membership",
          "tableTo": "team",
          "columnsFrom": [
            "teamId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_membership_userId_user_id_fk": {
          "name": "team_membership_userId_user_id_fk",
          "tableFrom": "team_membership",
          "tableTo": "user",
          "columnsFrom": [
            "userId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "team_membership_invitedBy_user_id_fk": {
          "name": "team_membership_invitedBy_user_id_fk",
          "tableFrom": "team_membership",
          "tableTo": "user",
          "columnsFrom": [
            "invitedBy"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team_role": {
      "name": "team_role",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "teamId": {
          "name": "teamId",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(1000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "permissions": {
          "name": "permissions",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "metadata": {
          "name": "metadata",
          "type": "text(5000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "isEditable": {
          "name": "isEditable",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        }
      },
      "indexes": {
        "team_role_team_id_idx": {
          "name": "team_role_team_id_idx",
          "columns": [
            "teamId"
          ],
          "isUnique": false
        },
        "team_role_name_unique_idx": {
          "name": "team_role_name_unique_idx",
          "columns": [
            "teamId",
            "name"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {
        "team_role_teamId_team_id_fk": {
          "name": "team_role_teamId_team_id_fk",
          "tableFrom": "team_role",
          "tableTo": "team",
          "columnsFrom": [
            "teamId"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "team": {
      "name": "team",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "slug": {
          "name": "slug",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text(1000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatarUrl": {
          "name": "avatarUrl",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "settings": {
          "name": "settings",
          "type": "text(10000)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "billingEmail": {
          "name": "billingEmail",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "planId": {
          "name": "planId",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "planExpiresAt": {
          "name": "planExpiresAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "creditBalance": {
          "name": "creditBalance",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        }
      },
      "indexes": {
        "team_slug_unique": {
          "name": "team_slug_unique",
          "columns": [
            "slug"
          ],
          "isUnique": true
        },
        "team_slug_idx": {
          "name": "team_slug_idx",
          "columns": [
            "slug"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "user": {
      "name": "user",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "firstName": {
          "name": "firstName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "lastName": {
          "name": "lastName",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "email": {
          "name": "email",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "passwordHash": {
          "name": "passwordHash",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "role": {
          "name": "role",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'user'"
        },
        "emailVerified": {
          "name": "emailVerified",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "signUpIpAddress": {
          "name": "signUpIpAddress",
          "type": "text(100)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "googleAccountId": {
          "name": "googleAccountId",
          "type": "text(255)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "avatar": {
          "name": "avatar",
          "type": "text(600)",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "currentCredits": {
          "name": "currentCredits",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 0
        },
        "lastCreditRefreshAt": {
          "name": "lastCreditRefreshAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {
        "user_email_unique": {
          "name": "user_email_unique",
          "columns": [
            "email"
          ],
          "isUnique": true
        },
        "email_idx": {
          "name": "email_idx",
          "columns": [
            "email"
          ],
          "isUnique": false
        },
        "google_account_id_idx": {
          "name": "google_account_id_idx",
          "columns": [
            "googleAccountId"
          ],
          "isUnique": false
        },
        "role_idx": {
          "name": "role_idx",
          "columns": [
            "role"
          ],
          "isUnique": false
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "workout_movements": {
      "name": "workout_movements",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "workout_id": {
          "name": "workout_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "movement_id": {
          "name": "movement_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "workout_movements_workout_id_workouts_id_fk": {
          "name": "workout_movements_workout_id_workouts_id_fk",
          "tableFrom": "workout_movements",
          "tableTo": "workouts",
          "columnsFrom": [
            "workout_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "workout_movements_movement_id_movements_id_fk": {
          "name": "workout_movements_movement_id_movements_id_fk",
          "tableFrom": "workout_movements",
          "tableTo": "movements",
          "columnsFrom": [
            "movement_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "workout_tags": {
      "name": "workout_tags",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "workout_id": {
          "name": "workout_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "tag_id": {
          "name": "tag_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "workout_tags_workout_id_workouts_id_fk": {
          "name": "workout_tags_workout_id_workouts_id_fk",
          "tableFrom": "workout_tags",
          "tableTo": "workouts",
          "columnsFrom": [
            "workout_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        },
        "workout_tags_tag_id_spicy_tags_id_fk": {
          "name": "workout_tags_tag_id_spicy_tags_id_fk",
          "tableFrom": "workout_tags",
          "tableTo": "spicy_tags",
          "columnsFrom": [
            "tag_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    },
    "workouts": {
      "name": "workouts",
      "columns": {
        "createdAt": {
          "name": "createdAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updatedAt": {
          "name": "updatedAt",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "updateCounter": {
          "name": "updateCounter",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 0
        },
        "id": {
          "name": "id",
          "type": "text",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "description": {
          "name": "description",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "scope": {
          "name": "scope",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'private'"
        },
        "scheme": {
          "name": "scheme",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "reps_per_round": {
          "name": "reps_per_round",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "rounds_to_score": {
          "name": "rounds_to_score",
          "type": "integer",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": 1
        },
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "sugar_id": {
          "name": "sugar_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "tiebreak_scheme": {
          "name": "tiebreak_scheme",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "secondary_scheme": {
          "name": "secondary_scheme",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "workouts_user_id_user_id_fk": {
          "name": "workouts_user_id_user_id_fk",
          "tableFrom": "workouts",
          "tableTo": "user",
          "columnsFrom": [
            "user_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "checkConstraints": {}
    }
  },
  "views": {},
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: src/db/migrations/0000_init.sql
================
CREATE TABLE `user` (
	`id` text PRIMARY KEY NOT NULL,
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`firstName` text(255),
	`lastName` text(255),
	`email` text(255),
	`passwordHash` text,
	`role` text DEFAULT 'user' NOT NULL
);
--> statement-breakpoint
CREATE UNIQUE INDEX `user_email_unique` ON `user` (`email`);

================
File: src/db/migrations/0001_add_emailVerified.sql
================
ALTER TABLE `user` ADD `emailVerified` integer;

================
File: src/db/migrations/0003_add_google_sso.sql
================
ALTER TABLE `user` ADD `signUpIpAddress` text(100);--> statement-breakpoint
ALTER TABLE `user` ADD `googleAccountId` text(255);--> statement-breakpoint
ALTER TABLE `user` ADD `avatar` text(600);--> statement-breakpoint
CREATE INDEX `email_idx` ON `user` (`email`);--> statement-breakpoint
CREATE INDEX `google_account_id_idx` ON `user` (`googleAccountId`);--> statement-breakpoint
CREATE INDEX `role_idx` ON `user` (`role`);

================
File: src/db/migrations/0004_add_passkey_credentials.sql
================
CREATE TABLE `passkey_credential` (
	`id` text PRIMARY KEY NOT NULL,
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`userId` text NOT NULL,
	`credentialId` text(255) NOT NULL,
	`credentialPublicKey` text(255) NOT NULL,
	`counter` integer NOT NULL,
	`transports` text(255),
	`aaguid` text(255),
	`userAgent` text(255),
	`ipAddress` text(100),
	FOREIGN KEY (`userId`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE UNIQUE INDEX `passkey_credential_credentialId_unique` ON `passkey_credential` (`credentialId`);--> statement-breakpoint
CREATE INDEX `user_id_idx` ON `passkey_credential` (`userId`);--> statement-breakpoint
CREATE INDEX `credential_id_idx` ON `passkey_credential` (`credentialId`);

================
File: src/db/migrations/0005_add_opennext_cache_tables.sql
================
-- Create table for storing tags and their associated paths
CREATE TABLE IF NOT EXISTS tags (
    tag TEXT NOT NULL,
    path TEXT NOT NULL,
    UNIQUE(tag, path) ON CONFLICT REPLACE
);

-- Create table for storing revalidation timestamps
CREATE TABLE IF NOT EXISTS revalidations (
    tag TEXT NOT NULL,
    revalidatedAt INTEGER NOT NULL,
    UNIQUE(tag) ON CONFLICT REPLACE
);

================
File: src/db/migrations/0006_add_credit_billing_system.sql
================
CREATE TABLE `credit_transaction` (
	`id` text PRIMARY KEY NOT NULL,
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`userId` text NOT NULL,
	`amount` integer NOT NULL,
	`remainingAmount` integer DEFAULT 0 NOT NULL,
	`type` text NOT NULL,
	`description` text(255) NOT NULL,
	`expirationDate` integer,
	`expirationDateProcessedAt` integer,
	FOREIGN KEY (`userId`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE INDEX `credit_transaction_user_id_idx` ON `credit_transaction` (`userId`);--> statement-breakpoint
CREATE INDEX `credit_transaction_type_idx` ON `credit_transaction` (`type`);--> statement-breakpoint
CREATE INDEX `credit_transaction_created_at_idx` ON `credit_transaction` (`createdAt`);--> statement-breakpoint
CREATE INDEX `credit_transaction_expiration_date_idx` ON `credit_transaction` (`expirationDate`);--> statement-breakpoint
CREATE TABLE `purchased_item` (
	`id` text PRIMARY KEY NOT NULL,
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`userId` text NOT NULL,
	`itemType` text NOT NULL,
	`itemId` text NOT NULL,
	`purchasedAt` integer NOT NULL,
	FOREIGN KEY (`userId`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE INDEX `purchased_item_user_id_idx` ON `purchased_item` (`userId`);--> statement-breakpoint
CREATE INDEX `purchased_item_type_idx` ON `purchased_item` (`itemType`);--> statement-breakpoint
CREATE INDEX `purchased_item_user_item_idx` ON `purchased_item` (`userId`,`itemType`,`itemId`);--> statement-breakpoint
ALTER TABLE `user` ADD `currentCredits` integer DEFAULT 0 NOT NULL;--> statement-breakpoint
ALTER TABLE `user` ADD `lastCreditRefreshAt` integer;

================
File: src/db/migrations/0007_add_update_counter_and_payment_intent_id.sql
================
ALTER TABLE `credit_transaction` ADD `updateCounter` integer DEFAULT 0;--> statement-breakpoint
ALTER TABLE `credit_transaction` ADD `paymentIntentId` text(255);--> statement-breakpoint
CREATE INDEX `credit_transaction_payment_intent_id_idx` ON `credit_transaction` (`paymentIntentId`);--> statement-breakpoint
ALTER TABLE `passkey_credential` ADD `updateCounter` integer DEFAULT 0;--> statement-breakpoint
ALTER TABLE `purchased_item` ADD `updateCounter` integer DEFAULT 0;--> statement-breakpoint
ALTER TABLE `user` ADD `updateCounter` integer DEFAULT 0;

================
File: src/db/migrations/0008_add_multi_tenancy.sql
================
CREATE TABLE `team_invitation` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`teamId` text NOT NULL,
	`email` text(255) NOT NULL,
	`roleId` text NOT NULL,
	`isSystemRole` integer DEFAULT 1 NOT NULL,
	`token` text(255) NOT NULL,
	`invitedBy` text NOT NULL,
	`expiresAt` integer NOT NULL,
	`acceptedAt` integer,
	`acceptedBy` text,
	FOREIGN KEY (`teamId`) REFERENCES `team`(`id`) ON UPDATE no action ON DELETE no action,
	FOREIGN KEY (`invitedBy`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE no action,
	FOREIGN KEY (`acceptedBy`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE UNIQUE INDEX `team_invitation_token_unique` ON `team_invitation` (`token`);--> statement-breakpoint
CREATE INDEX `team_invitation_team_id_idx` ON `team_invitation` (`teamId`);--> statement-breakpoint
CREATE INDEX `team_invitation_email_idx` ON `team_invitation` (`email`);--> statement-breakpoint
CREATE INDEX `team_invitation_token_idx` ON `team_invitation` (`token`);--> statement-breakpoint
CREATE TABLE `team_membership` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`teamId` text NOT NULL,
	`userId` text NOT NULL,
	`roleId` text NOT NULL,
	`isSystemRole` integer DEFAULT 1 NOT NULL,
	`invitedBy` text,
	`invitedAt` integer,
	`joinedAt` integer,
	`expiresAt` integer,
	`isActive` integer DEFAULT 1 NOT NULL,
	FOREIGN KEY (`teamId`) REFERENCES `team`(`id`) ON UPDATE no action ON DELETE no action,
	FOREIGN KEY (`userId`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE no action,
	FOREIGN KEY (`invitedBy`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE INDEX `team_membership_team_id_idx` ON `team_membership` (`teamId`);--> statement-breakpoint
CREATE INDEX `team_membership_user_id_idx` ON `team_membership` (`userId`);--> statement-breakpoint
CREATE INDEX `team_membership_unique_idx` ON `team_membership` (`teamId`,`userId`);--> statement-breakpoint
CREATE TABLE `team_role` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`teamId` text NOT NULL,
	`name` text(255) NOT NULL,
	`description` text(1000),
	`permissions` text NOT NULL,
	`metadata` text(5000),
	`isEditable` integer DEFAULT 1 NOT NULL,
	FOREIGN KEY (`teamId`) REFERENCES `team`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE INDEX `team_role_team_id_idx` ON `team_role` (`teamId`);--> statement-breakpoint
CREATE INDEX `team_role_name_unique_idx` ON `team_role` (`teamId`,`name`);--> statement-breakpoint
CREATE TABLE `team` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`name` text(255) NOT NULL,
	`slug` text(255) NOT NULL,
	`description` text(1000),
	`avatarUrl` text(600),
	`settings` text(10000),
	`billingEmail` text(255),
	`planId` text(100),
	`planExpiresAt` integer,
	`creditBalance` integer DEFAULT 0 NOT NULL
);
--> statement-breakpoint
CREATE UNIQUE INDEX `team_slug_unique` ON `team` (`slug`);--> statement-breakpoint
CREATE INDEX `team_slug_idx` ON `team` (`slug`);

================
File: src/db/migrations/0009_add_spicy_tables.sql
================
CREATE TABLE `movements` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`name` text NOT NULL,
	`type` text NOT NULL
);
--> statement-breakpoint
CREATE TABLE `results` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`user_id` text NOT NULL,
	`date` integer NOT NULL,
	`workout_id` text,
	`type` text NOT NULL,
	`notes` text,
	`scale` text,
	`wod_score` text,
	`set_count` integer,
	`distance` integer,
	`time` integer,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE no action,
	FOREIGN KEY (`workout_id`) REFERENCES `workouts`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE TABLE `sets` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`result_id` text NOT NULL,
	`set_number` integer NOT NULL,
	`reps` integer,
	`weight` integer,
	`status` text,
	`distance` integer,
	`time` integer,
	`score` integer,
	FOREIGN KEY (`result_id`) REFERENCES `results`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE TABLE `spicy_tags` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`name` text NOT NULL
);
--> statement-breakpoint
CREATE UNIQUE INDEX `spicy_tags_name_unique` ON `spicy_tags` (`name`);--> statement-breakpoint
CREATE TABLE `workout_movements` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`workout_id` text,
	`movement_id` text,
	FOREIGN KEY (`workout_id`) REFERENCES `workouts`(`id`) ON UPDATE no action ON DELETE no action,
	FOREIGN KEY (`movement_id`) REFERENCES `movements`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE TABLE `workout_tags` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`workout_id` text NOT NULL,
	`tag_id` text NOT NULL,
	FOREIGN KEY (`workout_id`) REFERENCES `workouts`(`id`) ON UPDATE no action ON DELETE no action,
	FOREIGN KEY (`tag_id`) REFERENCES `spicy_tags`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
CREATE TABLE `workouts` (
	`createdAt` integer NOT NULL,
	`updatedAt` integer NOT NULL,
	`updateCounter` integer DEFAULT 0,
	`id` text PRIMARY KEY NOT NULL,
	`name` text NOT NULL,
	`description` text NOT NULL,
	`scope` text DEFAULT 'private' NOT NULL,
	`scheme` text NOT NULL,
	`reps_per_round` integer,
	`rounds_to_score` integer DEFAULT 1,
	`user_id` text,
	`sugar_id` text,
	`tiebreak_scheme` text,
	`secondary_scheme` text,
	FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON UPDATE no action ON DELETE no action
);

================
File: src/db/migrations/0010_add_notes_to_sets.sql
================
ALTER TABLE `sets` ADD `notes` text;

================
File: src/db/index.ts
================
import { drizzle } from "drizzle-orm/d1";
import { getCloudflareContext } from "@opennextjs/cloudflare";
import type { DrizzleD1Database } from "drizzle-orm/d1";

import * as schema from "./schema";

export let db: DrizzleD1Database<typeof schema> | null = null;

export const getDB = () => {
  if (db) {
    return db;
  }

  const { env } = getCloudflareContext();

  if (!env.NEXT_TAG_CACHE_D1) {
    throw new Error("D1 database not found");
  }

  db = drizzle(env.NEXT_TAG_CACHE_D1, { schema, logger: true });

  return db;
};

================
File: src/server/logs.ts
================
import "server-only";
import { getDB } from "@/db";
import { results, sets, workouts } from "@/db/schema";
import { eq, desc } from "drizzle-orm";
import { createId } from "@paralleldrive/cuid2";
import type {
  WorkoutResultWithWorkoutName,
  ResultSet,
  ResultSetInput,
  Workout,
} from "@/types";
import { ZSAError } from "zsa";
import { requireVerifiedEmail } from "@/utils/auth";
import { formatSecondsToTime, parseTimeScoreToSeconds } from "@/lib/utils";
import { fromZonedTime } from "date-fns-tz";
import { headers } from "next/headers";

/**
 * Get all logs by user ID with workout names
 */
export async function getLogsByUser(
  userId: string
): Promise<WorkoutResultWithWorkoutName[]> {
  const db = getDB();
  console.log(`[getLogsByUser] Fetching logs for userId: ${userId}`);

  try {
    const logs = await db
      .select({
        id: results.id,
        userId: results.userId,
        date: results.date,
        workoutId: results.workoutId,
        type: results.type,
        notes: results.notes,
        scale: results.scale,
        wodScore: results.wodScore,
        setCount: results.setCount,
        distance: results.distance,
        time: results.time,
        createdAt: results.createdAt,
        updatedAt: results.updatedAt,
        updateCounter: results.updateCounter,
        workoutName: workouts.name,
      })
      .from(results)
      .leftJoin(workouts, eq(results.workoutId, workouts.id))
      .where(eq(results.userId, userId))
      .orderBy(desc(results.date));

    console.log(
      `[getLogsByUser] Found ${logs.length} logs for userId: ${userId}`
    );
    return logs.map((log) => ({
      ...log,
      workoutName: log.workoutName || undefined,
    })) as WorkoutResultWithWorkoutName[];
  } catch (error) {
    console.error(
      `[getLogsByUser] Error fetching logs for userId ${userId}:`,
      error
    );
    return [];
  }
}

/**
 * Add a new log entry with sets
 */
export async function addLog({
  userId,
  workoutId,
  date,
  scale,
  wodScore,
  notes,
  setsData,
  type,
}: {
  userId: string;
  workoutId: string;
  date: number;
  scale: "rx" | "scaled" | "rx+";
  wodScore: string;
  notes: string;
  setsData: ResultSetInput[];
  type: "wod" | "strength" | "monostructural";
}): Promise<void> {
  const session = await requireVerifiedEmail();
  if (!session) {
    throw new ZSAError("NOT_AUTHORIZED", "Not authenticated");
  }
  const db = getDB();
  const resultId = `result_${createId()}`;

  console.log(
    `[addLog] Adding log for userId: ${userId}, workoutId: ${workoutId}`
  );

  try {
    // Insert the main result - using timestamp mode for date field
    await db.insert(results).values({
      id: resultId,
      userId,
      workoutId,
      date: new Date(date),
      type,
      scale,
      wodScore,
      notes: notes || null,
      setCount: setsData.length || null,
    });

    // Insert sets if any
    if (setsData.length > 0) {
      const setsToInsert = setsData.map((set) => ({
        id: `set_${createId()}`,
        resultId,
        setNumber: set.setNumber,
        reps: set.reps || null,
        weight: set.weight || null,
        distance: set.distance || null,
        time: set.time || null,
        score: set.score || null,
        status: set.status || null,
      }));

      await db.insert(sets).values(setsToInsert);
      console.log(
        `[addLog] Added ${setsToInsert.length} sets for resultId: ${resultId}`
      );
    }

    console.log(`[addLog] Successfully added log with resultId: ${resultId}`);
  } catch (error) {
    console.error(`[addLog] Error adding log for userId ${userId}:`, error);
    throw error;
  }
}

/**
 * Get result sets by result ID
 */
export async function getResultSetsById(
  resultId: string
): Promise<ResultSet[]> {
  const db = getDB();
  console.log(`[getResultSetsById] Fetching sets for resultId: ${resultId}`);

  try {
    const setDetails = await db
      .select()
      .from(sets)
      .where(eq(sets.resultId, resultId))
      .orderBy(sets.setNumber);

    console.log(
      `[getResultSetsById] Found ${setDetails.length} sets for resultId ${resultId}`
    );
    return setDetails;
  } catch (error) {
    console.error(
      `[getResultSetsById] Error fetching sets for resultId ${resultId}:`,
      error
    );
    return [];
  }
}

// Form submission logic moved from actions.ts

interface BasicFormData {
  selectedWorkoutId: string | null;
  dateStr: string;
  scaleValue: "rx" | "scaled" | "rx+";
  notesValue: string;
  redirectUrl: string | null;
}

function parseBasicFormData(formData: FormData): BasicFormData {
  const selectedWorkoutId = formData.get("selectedWorkoutId") as string | null;
  const dateStr = formData.get("date") as string;
  const scaleValue = formData.get("scale") as "rx" | "scaled" | "rx+";
  const notesValue = formData.get("notes") as string;
  const redirectUrl = formData.get("redirectUrl") as string | null;
  return {
    selectedWorkoutId,
    dateStr,
    scaleValue,
    notesValue,
    redirectUrl,
  };
}

function parseScoreEntries(formData: FormData): Array<{ parts: string[] }> {
  const parsedScoreEntries: Array<{ parts: string[] }> = [];
  let roundIdx = 0;
  // Check for scores like scores[0][0], scores[0][1], scores[1][0] etc.
  while (formData.has(`scores[${roundIdx}][0]`)) {
    const parts: string[] = [];
    let partIdx = 0;
    while (formData.has(`scores[${roundIdx}][${partIdx}]`)) {
      parts.push(
        (formData.get(`scores[${roundIdx}][${partIdx}]`) as string) || ""
      );
      partIdx++;
    }
    if (parts.length > 0) {
      parsedScoreEntries.push({ parts });
    }
    roundIdx++;
  }
  return parsedScoreEntries;
}

function validateParsedScores(
  parsedScoreEntries: Array<{ parts: string[] }>,
  workoutScheme: Workout["scheme"]
): { error?: string } | undefined {
  const atLeastOneScorePartFilled = parsedScoreEntries.some((entry) =>
    entry.parts.some((part) => part.trim() !== "")
  );

  if (parsedScoreEntries.length === 0 || !atLeastOneScorePartFilled) {
    if (workoutScheme !== undefined) {
      // N/A scheme might not require scores
      console.error(
        "[Action] No valid score parts provided for a workout that expects scores."
      );
      return {
        error: "At least one score input is required and must not be empty.",
      };
    }
  }
  return undefined; // Explicitly return undefined if no error
}

interface ProcessedScoresOutput {
  setsForDb: ResultSetInput[];
  totalSecondsForWodScore: number;
  error?: { error: string };
}

function processScoreEntries(
  parsedScoreEntries: Array<{ parts: string[] }>,
  workout: Workout,
  isTimeBasedWodScore: boolean,
  isRoundsAndRepsWorkout: boolean,
  atLeastOneScorePartFilled: boolean // Added to resolve linter issues and use in logic
): ProcessedScoresOutput {
  const setsForDb: ResultSetInput[] = [];
  let totalSecondsForWodScore = 0;

  for (let k = 0; k < parsedScoreEntries.length; k++) {
    const entry = parsedScoreEntries[k];
    const setNumber = k + 1; // Set numbers are 1-indexed
    const scoreParts = entry.parts;

    if (isRoundsAndRepsWorkout) {
      // Expects two parts: scoreParts[0] = rounds, scoreParts[1] = reps
      if (scoreParts.length < 2 && scoreParts[0].trim() === "") {
        if (scoreParts.every((p) => p.trim() === "")) continue; // Skip fully empty entries
        return {
          setsForDb: [],
          totalSecondsForWodScore: 0,
          error: { error: `For round ${setNumber}, rounds input is required.` },
        };
      }

      const roundsStr = scoreParts[0] || "0";
      const repsStr = scoreParts[1] || "0";

      const roundsCompleted = Number.parseInt(roundsStr, 10);
      const repsCompleted = Number.parseInt(repsStr, 10);

      if (
        Number.isNaN(roundsCompleted) ||
        (scoreParts[1] !== undefined && Number.isNaN(repsCompleted))
      ) {
        return {
          setsForDb: [],
          totalSecondsForWodScore: 0,
          error: {
            error: `Invalid number for rounds or reps for set ${setNumber}. Rounds: '${roundsStr}', Reps: '${repsStr}'.`,
          },
        };
      }
      if (roundsCompleted < 0 || repsCompleted < 0) {
        return {
          setsForDb: [],
          totalSecondsForWodScore: 0,
          error: {
            error: `Rounds and reps for set ${setNumber} cannot be negative.`,
          },
        };
      }
      if (workout.repsPerRound === undefined)
        throw new Error("repsPerRound is required");
      const totalReps =
        roundsCompleted * (workout.repsPerRound ?? 0) + repsCompleted;

      setsForDb.push({
        setNumber,
        reps: totalReps,
        score: null,
        weight: null,
        status: null,
        distance: null,
        time: null,
      });
    } else if (workout.scheme === "time") {
      const timeStr = scoreParts[0];
      if (timeStr === undefined || timeStr.trim() === "") {
        if (parsedScoreEntries.length === 1 && !atLeastOneScorePartFilled) {
          // This case is handled by validateParsedScores
        } else if (scoreParts.every((p) => p.trim() === "")) {
          continue; // Skip if this specific score entry is completely empty
        }
        return {
          setsForDb: [],
          totalSecondsForWodScore: 0,
          error: { error: `Time input for set ${setNumber} is missing.` },
        };
      }
      const timeInSeconds = parseTimeScoreToSeconds(timeStr);
      if (timeInSeconds === null) {
        return {
          setsForDb: [],
          totalSecondsForWodScore: 0,
          error: {
            error: `Invalid time format for set ${setNumber}: '${timeStr}'. Please use MM:SS or total seconds.`,
          },
        };
      }
      if (isTimeBasedWodScore) {
        totalSecondsForWodScore += timeInSeconds;
      }
      setsForDb.push({
        setNumber,
        time: timeInSeconds,
        reps: null,
        weight: null,
        status: null,
        distance: null,
        score: null,
      });
    } else {
      // For schemes like 'reps', 'load', 'points'
      const scoreStr = scoreParts[0];
      if (scoreStr === undefined || scoreStr.trim() === "") {
        if (parsedScoreEntries.length === 1 && !atLeastOneScorePartFilled) {
          // Handled by validateParsedScores
        } else if (scoreParts.every((p) => p.trim() === "")) {
          continue; // Skip if this specific score entry is completely empty
        }
        return {
          setsForDb: [],
          totalSecondsForWodScore: 0,
          error: {
            error: `Score input for set ${setNumber} is missing for scheme '${workout.scheme}'.`,
          },
        };
      }
      const numericScore = Number.parseInt(scoreStr, 10);
      if (Number.isNaN(numericScore)) {
        return {
          setsForDb: [],
          totalSecondsForWodScore: 0,
          error: {
            error: `Score for set ${setNumber} ('${scoreStr}') must be a valid number for scheme '${workout.scheme}'.`,
          },
        };
      }
      if (numericScore < 0) {
        return {
          setsForDb: [],
          totalSecondsForWodScore: 0,
          error: {
            error: `Score for set ${setNumber} ('${numericScore}') cannot be negative.`,
          },
        };
      }
      setsForDb.push({
        setNumber,
        score: numericScore,
        reps: null,
        weight: null,
        status: null,
        distance: null,
        time: null,
      });
    }
  }
  return { setsForDb, totalSecondsForWodScore };
}

function validateProcessedSets(
  setsForDb: ResultSetInput[],
  workoutScheme: Workout["scheme"],
  atLeastOneScorePartFilled: boolean
): { error?: string } | undefined {
  if (
    setsForDb.length === 0 &&
    workoutScheme !== undefined &&
    atLeastOneScorePartFilled
  ) {
    console.error(
      "[Action] All provided score entries resulted in no valid sets to save, but some input was detected."
    );
    return {
      error:
        "Valid score information is required. Please check your inputs for each round/set.",
    };
  }
  if (
    setsForDb.length === 0 &&
    workoutScheme !== undefined &&
    !atLeastOneScorePartFilled
  ) {
    console.error(
      "[Action] No score entries provided or all were empty, and workout expects scores."
    );
    return {
      error: "At least one score input is required and must not be empty.",
    };
  }
  return undefined;
}

function generateWodScoreSummary(
  isTimeBasedWodScore: boolean,
  totalSecondsForWodScore: number,
  parsedScoreEntries: Array<{ parts: string[] }>,
  isRoundsAndRepsWorkout: boolean,
  workoutScheme: Workout["scheme"],
  setsForDb: ResultSetInput[], // Added to check conditions for time-based summary
  atLeastOneScorePartFilled: boolean // Added for conditional logic
): string {
  let finalWodScoreSummary = "";
  if (isTimeBasedWodScore) {
    finalWodScoreSummary = formatSecondsToTime(totalSecondsForWodScore);
    if (
      totalSecondsForWodScore === 0 &&
      setsForDb.some((set) => set?.time && set.time > 0)
    ) {
      // This means valid times were logged, but somehow total is still 0. Should not happen.
    } else if (
      totalSecondsForWodScore === 0 &&
      parsedScoreEntries.length > 0 &&
      !atLeastOneScorePartFilled
    ) {
      // No score parts filled, an error should have been caught earlier
      // For safety, can return empty or specific string like "No Score"
      finalWodScoreSummary = ""; // Or "No Score"
    } else if (
      totalSecondsForWodScore === 0 &&
      setsForDb.length === 0 &&
      atLeastOneScorePartFilled
    ) {
      // some input, but no valid sets. Error should be caught.
      // For safety, can return empty or specific string like "No Score"
      finalWodScoreSummary = ""; // Or "No Score"
    }
  } else {
    const scoreSummaries: string[] = [];
    for (let k = 0; k < parsedScoreEntries.length; k++) {
      const entry = parsedScoreEntries[k];
      const scoreParts = entry.parts;

      if (isRoundsAndRepsWorkout) {
        const roundsStr = scoreParts[0] || "0";
        const repsStr = scoreParts[1] || "0";
        if (
          roundsStr === "0" &&
          repsStr === "0" &&
          scoreParts.every((p) => p.trim() === "")
        ) {
          // Potentially skip
        } else {
          scoreSummaries.push(`${roundsStr} + ${repsStr}`);
        }
      } else if (workoutScheme === "time") {
        const timeStr = scoreParts[0];
        if (timeStr && timeStr.trim() !== "") {
          scoreSummaries.push(timeStr);
        }
      } else {
        const scoreStr = scoreParts[0];
        if (scoreStr && scoreStr.trim() !== "") {
          scoreSummaries.push(scoreStr);
        }
      }
    }
    finalWodScoreSummary = scoreSummaries.join(", ");
  }
  return finalWodScoreSummary;
}

async function submitLogToDatabase(
  userId: string,
  selectedWorkoutId: string,
  dateStr: string,
  timezone: string,
  scaleValue: "rx" | "scaled" | "rx+",
  finalWodScoreSummary: string,
  notesValue: string,
  setsForDb: ResultSetInput[]
) {
  console.log("[Action] Submitting log with sets:", {
    userId,
    selectedWorkoutId,
    date: dateStr,
    scale: scaleValue,
    wodScoreSummary: finalWodScoreSummary,
    notes: notesValue,
    sets: setsForDb,
  });

  console.log("[Action] Date in timezone:", new Date(dateStr).getTime());

  try {
    const dateInTargetTz = fromZonedTime(`${dateStr}T00:00:00`, timezone);
    const timestamp = dateInTargetTz.getTime();

    console.log(
      `[Action] Original date string: ${dateStr}, Target Timezone: ${timezone}, Timestamp: ${timestamp}`
    );

    return await addLog({
      userId,
      workoutId: selectedWorkoutId,
      date: timestamp,
      scale: scaleValue,
      wodScore: finalWodScoreSummary,
      notes: notesValue,
      setsData: setsForDb,
      type: "wod",
    });
  } catch (error) {
    console.error("[Action] Failed to add log with sets:", error);
    return {
      error: `Failed to save log: ${
        error instanceof Error ? error.message : String(error)
      }`,
    };
  }
}

export async function submitLogForm(
  userId: string,
  workouts: Workout[],
  formData: FormData
) {
  const headerList = await headers();
  const timezone = headerList.get("x-vercel-ip-timezone") ?? "America/Denver";
  const { selectedWorkoutId, dateStr, scaleValue, notesValue } =
    parseBasicFormData(formData);

  console.log("[Action] Date:", dateStr);

  if (!selectedWorkoutId) {
    console.error("[Action] No workout selected");
    return { error: "No workout selected. Please select a workout." };
  }

  const workout = workouts.find((w) => w.id === selectedWorkoutId);

  if (!workout) {
    console.error("[Action] Workout not found for ID:", selectedWorkoutId);
    return { error: "Selected workout not found. Please try again." };
  }

  const parsedScoreEntries = parseScoreEntries(formData);
  console.log(
    "[Action] Parsed Score Entries:",
    JSON.stringify(parsedScoreEntries)
  );

  const validationError = validateParsedScores(
    parsedScoreEntries,
    workout.scheme
  );
  if (validationError) {
    return validationError;
  }

  const atLeastOneScorePartFilled = parsedScoreEntries.some((entry) =>
    entry.parts.some((part) => part.trim() !== "")
  );

  const isRoundsAndRepsWorkout =
    !!workout.repsPerRound && workout.repsPerRound > 0;

  const isTimeBasedWodScore =
    workout.scheme === "time" || workout.scheme === "time-with-cap";

  const processResult = processScoreEntries(
    parsedScoreEntries,
    workout,
    isTimeBasedWodScore,
    isRoundsAndRepsWorkout,
    atLeastOneScorePartFilled
  );

  if (processResult.error) {
    return { error: processResult.error.error };
  }

  const { setsForDb, totalSecondsForWodScore } = processResult;

  const processedSetsValidationError = validateProcessedSets(
    setsForDb,
    workout.scheme,
    atLeastOneScorePartFilled
  );
  if (processedSetsValidationError) {
    return processedSetsValidationError;
  }

  const finalWodScoreSummary = generateWodScoreSummary(
    isTimeBasedWodScore,
    totalSecondsForWodScore,
    parsedScoreEntries,
    isRoundsAndRepsWorkout,
    workout.scheme,
    setsForDb,
    atLeastOneScorePartFilled
  );

  return submitLogToDatabase(
    userId,
    selectedWorkoutId,
    dateStr,
    timezone,
    scaleValue,
    finalWodScoreSummary,
    notesValue,
    setsForDb
  );
}

================
File: src/server/tags.ts
================
import "server-only";
import { getDB } from "@/db";
import { tags } from "@/db/schema";
import { requireVerifiedEmail } from "@/utils/auth";
import { ZSAError } from "zsa";

/**
 * Get all tags available in the system
 */
export async function getAllTags() {
  const session = await requireVerifiedEmail();

  if (!session) {
    throw new ZSAError("NOT_AUTHORIZED", "Not authenticated");
  }

  const db = getDB();

  const allTags = await db.select().from(tags);

  return allTags;
}

================
File: src/server/team-members.ts
================
import "server-only";
import { getDB } from "@/db";
import { SYSTEM_ROLES_ENUM, teamInvitationTable, teamMembershipTable, userTable, teamRoleTable, teamTable } from "@/db/schema";
import { getSessionFromCookie } from "@/utils/auth";
import { ZSAError } from "zsa";
import { createId } from "@paralleldrive/cuid2";
import { eq, and, isNull, count } from "drizzle-orm";
import { TEAM_PERMISSIONS } from "@/db/schema";
import { requireTeamPermission } from "@/utils/team-auth";
import { updateAllSessionsOfUser } from "@/utils/kv-session";
import { canSignUp } from "@/utils/auth";
import { MAX_TEAMS_JOINED_PER_USER } from "@/constants";
import { sendTeamInvitationEmail } from "@/utils/email";

/**
 * Get all members of a team
 */
export async function getTeamMembers(teamId: string) {
  // Check if user has access to the team
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.ACCESS_DASHBOARD);

  const db = getDB();

  const members = await db.query.teamMembershipTable.findMany({
    where: eq(teamMembershipTable.teamId, teamId),
    with: {
      user: {
        columns: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          avatar: true,
        }
      }
    },
  });

  // Get all team roles for this team (for custom roles)
  const teamRoles = await db.query.teamRoleTable.findMany({
    where: eq(teamRoleTable.teamId, teamId),
  });

  // Map roles by ID for easy lookup
  const roleMap = new Map(teamRoles.map(role => [role.id, role.name]));

  return Promise.all(members.map(async member => {
    let roleName = "Unknown";

    // For system roles, use the roleId directly as the name
    if (member.isSystemRole) {
      // Capitalize the first letter for display
      roleName = member.roleId.charAt(0).toUpperCase() + member.roleId.slice(1);
    } else {
      // For custom roles, look up the name in our roleMap
      roleName = roleMap.get(member.roleId) || "Custom Role";
    }

    return {
      id: member.id,
      userId: member.userId,
      roleId: member.roleId,
      roleName,
      isSystemRole: Boolean(member.isSystemRole),
      isActive: Boolean(member.isActive),
      joinedAt: member.joinedAt ? new Date(member.joinedAt) : null,
      user: {
        id: member.user.id,
        firstName: member.user.firstName,
        lastName: member.user.lastName,
        email: member.user.email,
        avatar: member.user.avatar,
      }
    };
  }));
}

/**
 * Update a team member's role
 */
export async function updateTeamMemberRole({
  teamId,
  userId,
  roleId,
  isSystemRole = false
}: {
  teamId: string;
  userId: string;
  roleId: string;
  isSystemRole?: boolean;
}) {
  // Check if user has permission to change member roles
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.CHANGE_MEMBER_ROLES);

  const db = getDB();

  // Verify membership exists
  const membership = await db.query.teamMembershipTable.findFirst({
    where: and(
      eq(teamMembershipTable.teamId, teamId),
      eq(teamMembershipTable.userId, userId)
    ),
  });

  if (!membership) {
    throw new ZSAError("NOT_FOUND", "Team membership not found");
  }

  // Update the role
  await db.update(teamMembershipTable)
    .set({
      roleId,
      isSystemRole: isSystemRole ? 1 : 0,
      updatedAt: new Date(),
    })
    .where(
      and(
        eq(teamMembershipTable.teamId, teamId),
        eq(teamMembershipTable.userId, userId)
      )
    );

  // Update the user's session to reflect the new role
  await updateAllSessionsOfUser(userId);

  return { success: true };
}

/**
 * Remove a member from a team
 */
export async function removeTeamMember({
  teamId,
  userId
}: {
  teamId: string;
  userId: string;
}) {
  // Check if user has permission to remove members
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.REMOVE_MEMBERS);

  const db = getDB();

  // Verify membership exists
  const membership = await db.query.teamMembershipTable.findFirst({
    where: and(
      eq(teamMembershipTable.teamId, teamId),
      eq(teamMembershipTable.userId, userId)
    ),
  });

  if (!membership) {
    throw new ZSAError("NOT_FOUND", "Team membership not found");
  }

  // Don't allow removing an owner
  if (membership.roleId === SYSTEM_ROLES_ENUM.OWNER && membership.isSystemRole) {
    throw new ZSAError("FORBIDDEN", "Cannot remove the team owner");
  }

  // Delete the membership
  await db.delete(teamMembershipTable)
    .where(
      and(
        eq(teamMembershipTable.teamId, teamId),
        eq(teamMembershipTable.userId, userId)
      )
    );

  // Update the user's session to remove this team
  await updateAllSessionsOfUser(userId);

  return { success: true };
}

/**
 * Invite a user to join a team
 */
export async function inviteUserToTeam({
  teamId,
  email,
  roleId,
  isSystemRole = true
}: {
  teamId: string;
  email: string;
  roleId: string;
  isSystemRole?: boolean;
}) {
  // Check if user has permission to invite members
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.INVITE_MEMBERS);

  const session = await getSessionFromCookie();

  if (!session) {
    throw new ZSAError("NOT_AUTHORIZED", "Not authenticated");
  }

  // Validate email
  try {
    await canSignUp({ email });
  } catch (error) {
    if (error instanceof ZSAError) {
      throw error;
    }
    throw new ZSAError("ERROR", "Invalid or disposable email address");
  }

  const db = getDB();

  // Get team name for email
  const team = await db.query.teamTable.findFirst({
    where: eq(teamTable.id, teamId),
  });

  if (!team) {
    throw new ZSAError("NOT_FOUND", "Team not found");
  }

  const teamName = team.name as string || "Team";

  // Get inviter's name for email
  const inviter = {
    firstName: session.user.firstName || "",
    lastName: session.user.lastName || "",
    fullName: `${session.user.firstName || ""} ${session.user.lastName || ""}`.trim() || session.user.email,
  };

  // Check if user is already a member
  const existingUser = await db.query.userTable.findFirst({
    where: eq(userTable.email, email),
  });

  if (existingUser) {
    const existingMembership = await db.query.teamMembershipTable.findFirst({
      where: and(
        eq(teamMembershipTable.teamId, teamId),
        eq(teamMembershipTable.userId, existingUser.id)
      ),
    });

    if (existingMembership) {
      throw new ZSAError("CONFLICT", "User is already a member of this team");
    }

    // Check if user has reached their team joining limit
    const teamsCountResult = await db.select({ value: count() })
      .from(teamMembershipTable)
      .where(eq(teamMembershipTable.userId, existingUser.id));

    const teamsJoined = teamsCountResult[0]?.value || 0;

    if (teamsJoined >= MAX_TEAMS_JOINED_PER_USER) {
      throw new ZSAError("FORBIDDEN", `This user has reached the limit of ${MAX_TEAMS_JOINED_PER_USER} teams they can join.`);
    }

    // User exists but is not a member, add them directly
    await db.insert(teamMembershipTable).values({
      teamId,
      userId: existingUser.id,
      roleId,
      isSystemRole: isSystemRole ? 1 : 0,
      invitedBy: session.userId,
      invitedAt: new Date(),
      joinedAt: new Date(),
      isActive: 1,
    });

    // Update the user's session to include this team
    await updateAllSessionsOfUser(existingUser.id);

    return {
      success: true,
      userJoined: true,
      userId: existingUser.id,
    };
  }

  // User doesn't exist, create an invitation
  const token = createId();
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 7); // Valid for 7 days

  // Check if there's an existing invitation
  const existingInvitation = await db.query.teamInvitationTable.findFirst({
    where: and(
      eq(teamInvitationTable.teamId, teamId),
      eq(teamInvitationTable.email, email)
    ),
  });

  if (existingInvitation) {
    // Update the existing invitation
    await db.update(teamInvitationTable)
      .set({
        roleId,
        isSystemRole: isSystemRole ? 1 : 0,
        token,
        expiresAt,
        invitedBy: session.userId,
        acceptedAt: null,
        acceptedBy: null,
        updatedAt: new Date(),
      })
      .where(eq(teamInvitationTable.id, existingInvitation.id));

    // Send invitation email
    await sendTeamInvitationEmail({
      email,
      invitationToken: token,
      teamName,
      inviterName: inviter.fullName || "Team Owner",
    });

    return {
      success: true,
      invitationSent: true,
      invitationId: existingInvitation.id,
    };
  }

  const newInvitation = await db.insert(teamInvitationTable).values({
    teamId,
    email,
    roleId,
    isSystemRole: isSystemRole ? 1 : 0,
    token,
    invitedBy: session.userId,
    expiresAt,
  }).returning();

  const invitation = newInvitation?.[0];

  if (!invitation) {
    throw new ZSAError("ERROR", "Could not create invitation");
  }

  // Send invitation email
  await sendTeamInvitationEmail({
    email,
    invitationToken: token,
    teamName,
    inviterName: inviter.fullName || "Team Owner",
  });

  return {
    success: true,
    invitationSent: true,
    invitationId: invitation.id,
  };
}

/**
 * Accept a team invitation
 */
export async function acceptTeamInvitation(token: string) {
  const session = await getSessionFromCookie();

  if (!session) {
    throw new ZSAError("NOT_AUTHORIZED", "Not authenticated");
  }

  const db = getDB();

  // Find the invitation by token
  const invitation = await db.query.teamInvitationTable.findFirst({
    where: eq(teamInvitationTable.token, token),
  });

  if (!invitation) {
    throw new ZSAError("NOT_FOUND", "Invitation not found");
  }

  // Check if invitation has expired
  if (invitation.expiresAt && new Date(invitation.expiresAt) < new Date()) {
    throw new ZSAError("ERROR", "Invitation has expired");
  }

  // Check if invitation was already accepted
  if (invitation.acceptedAt) {
    throw new ZSAError("CONFLICT", "Invitation has already been accepted");
  }

  // Check if user's email matches the invitation email
  if (session.user.email !== invitation.email) {
    throw new ZSAError("FORBIDDEN", "This invitation is for a different email address");
  }

  // Check if user is already a member
  const existingMembership = await db.query.teamMembershipTable.findFirst({
    where: and(
      eq(teamMembershipTable.teamId, invitation.teamId),
      eq(teamMembershipTable.userId, session.userId)
    ),
  });

  if (existingMembership) {
    // Mark invitation as accepted
    await db.update(teamInvitationTable)
      .set({
        acceptedAt: new Date(),
        acceptedBy: session.userId,
        updatedAt: new Date(),
      })
      .where(eq(teamInvitationTable.id, invitation.id));

    throw new ZSAError("CONFLICT", "You are already a member of this team");
  }

  // Check if user has reached their team joining limit
  const teamsCountResult = await db.select({ value: count() })
    .from(teamMembershipTable)
    .where(eq(teamMembershipTable.userId, session.userId));

  const teamsJoined = teamsCountResult[0]?.value || 0;

  if (teamsJoined >= MAX_TEAMS_JOINED_PER_USER) {
    throw new ZSAError("FORBIDDEN", `You have reached the limit of ${MAX_TEAMS_JOINED_PER_USER} teams you can join.`);
  }

  // Add user to the team
  await db.insert(teamMembershipTable).values({
    teamId: invitation.teamId,
    userId: session.userId,
    roleId: invitation.roleId,
    isSystemRole: Number(invitation.isSystemRole),
    invitedBy: invitation.invitedBy,
    invitedAt: invitation.createdAt ? new Date(invitation.createdAt) : new Date(),
    joinedAt: new Date(),
    isActive: 1,
  });

  // Mark invitation as accepted
  await db.update(teamInvitationTable)
    .set({
      acceptedAt: new Date(),
      acceptedBy: session.userId,
      updatedAt: new Date(),
    })
    .where(eq(teamInvitationTable.id, invitation.id));

  // Update the user's session to include this team
  await updateAllSessionsOfUser(session.userId);

  return {
    success: true,
    teamId: invitation.teamId,
  };
}

/**
 * Get pending invitations for a team
 */
export async function getTeamInvitations(teamId: string) {
  // Check if user has permission to view invitations
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.INVITE_MEMBERS);

  const db = getDB();

  // Get invitations that have not been accepted
  const invitations = await db.query.teamInvitationTable.findMany({
    where: and(
      eq(teamInvitationTable.teamId, teamId),
      isNull(teamInvitationTable.acceptedAt)
    ),
    with: {
      invitedByUser: {
        columns: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          avatar: true,
        }
      }
    },
  });

  return invitations.map(invitation => ({
    id: invitation.id,
    email: invitation.email,
    roleId: invitation.roleId,
    isSystemRole: Boolean(invitation.isSystemRole),
    createdAt: new Date(invitation.createdAt),
    expiresAt: invitation.expiresAt ? new Date(invitation.expiresAt) : null,
    invitedBy: {
      id: invitation.invitedByUser.id,
      firstName: invitation.invitedByUser.firstName,
      lastName: invitation.invitedByUser.lastName,
      email: invitation.invitedByUser.email,
      avatar: invitation.invitedByUser.avatar,
    }
  }));
}

/**
 * Cancel a team invitation
 */
export async function cancelTeamInvitation(invitationId: string) {
  const db = getDB();

  // Find the invitation
  const invitation = await db.query.teamInvitationTable.findFirst({
    where: eq(teamInvitationTable.id, invitationId),
  });

  if (!invitation) {
    throw new ZSAError("NOT_FOUND", "Invitation not found");
  }

  // Check if user has permission to cancel invitations for this team
  await requireTeamPermission(invitation.teamId, TEAM_PERMISSIONS.INVITE_MEMBERS);

  // Delete the invitation
  await db.delete(teamInvitationTable)
    .where(eq(teamInvitationTable.id, invitationId));

  return { success: true };
}

/**
 * Get pending invitations for the current user
 */
export async function getPendingInvitationsForCurrentUser() {
  const session = await getSessionFromCookie();

  if (!session) {
    throw new ZSAError("NOT_AUTHORIZED", "Not authenticated");
  }

  const db = getDB();

  // Get invitations for the user's email that have not been accepted
  const invitations = await db.query.teamInvitationTable.findMany({
    where: and(
      session.user.email ? eq(teamInvitationTable.email, session.user.email) : undefined,
      isNull(teamInvitationTable.acceptedAt)
    ),
    with: {
      team: {
        columns: {
          id: true,
          name: true,
          slug: true,
          avatarUrl: true,
        }
      },
      invitedByUser: {
        columns: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          avatar: true,
        }
      }
    },
  });

  return invitations.map(invitation => ({
    id: invitation.id,
    token: invitation.token,
    teamId: invitation.teamId,
    team: {
      id: invitation.team.id,
      name: invitation.team.name,
      slug: invitation.team.slug,
      avatarUrl: invitation.team.avatarUrl,
    },
    roleId: invitation.roleId,
    isSystemRole: Boolean(invitation.isSystemRole),
    createdAt: new Date(invitation.createdAt),
    expiresAt: invitation.expiresAt ? new Date(invitation.expiresAt) : null,
    invitedBy: {
      id: invitation.invitedByUser.id,
      firstName: invitation.invitedByUser.firstName,
      lastName: invitation.invitedByUser.lastName,
      email: invitation.invitedByUser.email,
      avatar: invitation.invitedByUser.avatar,
    }
  }));
}

================
File: src/server/team-roles.ts
================
import "server-only";
import { getDB } from "@/db";
import { TEAM_PERMISSIONS, teamRoleTable } from "@/db/schema";
import { ZSAError } from "zsa";
import { eq, and, not } from "drizzle-orm";
import { requireTeamPermission } from "@/utils/team-auth";

/**
 * Get all custom roles for a team
 */
export async function getTeamRoles(teamId: string) {
  // Check if user has access to the team
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.ACCESS_DASHBOARD);

  const db = getDB();

  const roles = await db.query.teamRoleTable.findMany({
    where: eq(teamRoleTable.teamId, teamId),
  });

  return roles.map(role => ({
    id: role.id,
    name: role.name,
    description: role.description,
    permissions: role.permissions as string[],
    isEditable: Boolean(role.isEditable),
    metadata: role.metadata,
  }));
}

/**
 * Create a new custom role for a team
 */
export async function createTeamRole({
  teamId,
  name,
  description,
  permissions,
  metadata
}: {
  teamId: string;
  name: string;
  description?: string;
  permissions: string[];
  metadata?: Record<string, unknown>;
}) {
  // Check if user has permission to create roles
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.CREATE_ROLES);

  const db = getDB();

  // Check if a role with the same name already exists
  const existingRole = await db.query.teamRoleTable.findFirst({
    where: and(
      eq(teamRoleTable.teamId, teamId),
      eq(teamRoleTable.name, name)
    ),
  });

  if (existingRole) {
    throw new ZSAError("CONFLICT", "A role with this name already exists");
  }

  const newRole = await db.insert(teamRoleTable).values({
    teamId,
    name,
    description,
    permissions,
    metadata: metadata ? JSON.stringify(metadata) : null,
    isEditable: 1,
  }).returning();

  const role = newRole?.[0];

  if (!role) {
    throw new ZSAError("ERROR", "Could not create role");
  }

  return {
    id: role.id,
    name,
    description,
    permissions,
    isEditable: true,
    metadata,
  };
}

/**
 * Update an existing team role
 */
export async function updateTeamRole({
  teamId,
  roleId,
  data
}: {
  teamId: string;
  roleId: string;
  data: {
    name?: string;
    description?: string;
    permissions?: string[];
    metadata?: Record<string, unknown>;
  };
}) {
  // Check if user has permission to edit roles
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.EDIT_ROLES);

  const db = getDB();

  // Find the role to update
  const role = await db.query.teamRoleTable.findFirst({
    where: and(
      eq(teamRoleTable.id, roleId),
      eq(teamRoleTable.teamId, teamId)
    ),
  });

  if (!role) {
    throw new ZSAError("NOT_FOUND", "Role not found");
  }

  // Prevent editing non-editable roles
  if (!role.isEditable) {
    throw new ZSAError("FORBIDDEN", "This role cannot be edited");
  }

  // Check if the new name would conflict with an existing role
  if (data.name && data.name !== role.name) {
    const existingRole = await db.query.teamRoleTable.findFirst({
      where: and(
        eq(teamRoleTable.teamId, teamId),
        eq(teamRoleTable.name, data.name),
        not(eq(teamRoleTable.id, roleId))
      ),
    });

    if (existingRole) {
      throw new ZSAError("CONFLICT", "A role with this name already exists");
    }
  }

  // Update the role
  const updateData: Record<string, unknown> = {};

  if (data.name) updateData.name = data.name;
  if (data.description !== undefined) updateData.description = data.description;
  if (data.permissions) updateData.permissions = data.permissions;
  if (data.metadata !== undefined) {
    updateData.metadata = data.metadata ? JSON.stringify(data.metadata) : null;
  }

  await db.update(teamRoleTable)
    .set({
      ...updateData,
      updatedAt: new Date(),
    })
    .where(eq(teamRoleTable.id, roleId));

  return {
    id: roleId,
    name: data.name || role.name,
    description: data.description !== undefined ? data.description : role.description,
    permissions: data.permissions || role.permissions,
    isEditable: Boolean(role.isEditable),
    metadata: data.metadata !== undefined ? data.metadata : role.metadata,
  };
}

/**
 * Delete a team role
 */
export async function deleteTeamRole({
  teamId,
  roleId
}: {
  teamId: string;
  roleId: string;
}) {
  // Check if user has permission to delete roles
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.DELETE_ROLES);

  const db = getDB();

  // Find the role to delete
  const role = await db.query.teamRoleTable.findFirst({
    where: and(
      eq(teamRoleTable.id, roleId),
      eq(teamRoleTable.teamId, teamId)
    ),
  });

  if (!role) {
    throw new ZSAError("NOT_FOUND", "Role not found");
  }

  // Prevent deleting non-editable roles
  if (!role.isEditable) {
    throw new ZSAError("FORBIDDEN", "This role cannot be deleted");
  }

  // Delete the role
  await db.delete(teamRoleTable)
    .where(eq(teamRoleTable.id, roleId));

  return { success: true };
}

================
File: src/server/teams.ts
================
import "server-only";
import { getDB } from "@/db";
import { SYSTEM_ROLES_ENUM, TEAM_PERMISSIONS, teamMembershipTable, teamRoleTable, teamTable } from "@/db/schema";
import { requireVerifiedEmail } from "@/utils/auth";
import { generateSlug } from "@/utils/slugify";
import { ZSAError } from "zsa";
import { createId } from "@paralleldrive/cuid2";
import { eq, and, not, count } from "drizzle-orm";
import { requireTeamPermission } from "@/utils/team-auth";
import { updateAllSessionsOfUser } from "@/utils/kv-session";
import { MAX_TEAMS_CREATED_PER_USER, MAX_TEAMS_JOINED_PER_USER } from "@/constants";

/**
 * Create a new team with the current user as owner
 */
export async function createTeam({
  name,
  description,
  avatarUrl
}: {
  name: string;
  description?: string;
  avatarUrl?: string;
}) {
  // Verify user is authenticated
  const session = await requireVerifiedEmail();
  if (!session) {
    throw new ZSAError("NOT_AUTHORIZED", "Not authenticated");
  }

  const userId = session.userId;
  const db = getDB();

  // Check if user has reached their team creation limit
  const ownedTeamsCount = await db.select({ value: count() })
    .from(teamMembershipTable)
    .where(
      and(
        eq(teamMembershipTable.userId, userId),
        eq(teamMembershipTable.roleId, SYSTEM_ROLES_ENUM.OWNER),
        eq(teamMembershipTable.isSystemRole, 1)
      )
    );

  const teamsOwned = ownedTeamsCount[0]?.value || 0;

  if (teamsOwned >= MAX_TEAMS_CREATED_PER_USER) {
    throw new ZSAError("FORBIDDEN", `You have reached the limit of ${MAX_TEAMS_CREATED_PER_USER} teams you can create.`);
  }

  // Generate unique slug for the team
  let slug = generateSlug(name);
  let slugIsUnique = false;
  let attempts = 0;

  // Make sure slug is unique
  while (!slugIsUnique && attempts < 5) {
    const existingTeam = await db.query.teamTable.findFirst({
      where: eq(teamTable.slug, slug),
    });

    if (!existingTeam) {
      slugIsUnique = true;
    } else {
      // Add a random suffix to make the slug unique
      slug = `${generateSlug(name)}-${createId().substring(0, 4)}`;
      attempts++;
    }
  }

  if (!slugIsUnique) {
    throw new ZSAError("ERROR", "Could not generate a unique slug for the team");
  }

  // Insert the team
  const newTeam = await db.insert(teamTable).values({
    name,
    slug,
    description,
    avatarUrl,
    creditBalance: 0,
  }).returning();

  const team = newTeam?.[0];

  if (!team) {
    throw new ZSAError("ERROR", "Could not create team");
  }

  const teamId = team.id;

  // Add the creator as an owner
  await db.insert(teamMembershipTable).values({
    teamId,
    userId,
    roleId: SYSTEM_ROLES_ENUM.OWNER,
    isSystemRole: 1,
    invitedBy: userId,
    invitedAt: new Date(),
    joinedAt: new Date(),
    isActive: 1,
  });

  // Create default custom role for the team
  await db.insert(teamRoleTable).values({
    teamId,
    name: "Editor",
    description: "Can edit team content",
    permissions: [
      TEAM_PERMISSIONS.ACCESS_DASHBOARD,
      TEAM_PERMISSIONS.CREATE_COMPONENTS,
      TEAM_PERMISSIONS.EDIT_COMPONENTS,
    ],
    isEditable: 1,
  });

  // Update the user's session to include the new team
  await updateAllSessionsOfUser(userId);

  return {
    teamId,
    name,
    slug,
  };
}

/**
 * Update a team's details
 */
export async function updateTeam({
  teamId,
  data
}: {
  teamId: string;
  data: {
    name?: string;
    description?: string;
    avatarUrl?: string;
    billingEmail?: string;
    settings?: string;
  };
}) {
  // Check if user has permission to update team settings
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.EDIT_TEAM_SETTINGS);

  const db = getDB();

  // If name is being updated, check if we need to update the slug
  if (data.name) {
    const currentTeam = await db.query.teamTable.findFirst({
      where: eq(teamTable.id, teamId),
    });

    if (currentTeam && currentTeam.name !== data.name) {
      // Generate new slug based on the new name
      let newSlug = generateSlug(data.name);
      let slugIsUnique = false;
      let attempts = 0;

      while (!slugIsUnique && attempts < 5) {
        const existingTeam = await db.query.teamTable.findFirst({
          where: and(
            eq(teamTable.slug, newSlug),
            // Make sure we don't check against our own team
            not(eq(teamTable.id, teamId))
          ),
        });

        if (!existingTeam) {
          slugIsUnique = true;
        } else {
          // Add a random suffix to make the slug unique
          newSlug = `${generateSlug(data.name)}-${createId().substring(0, 4)}`;
          attempts++;
        }
      }

      if (!slugIsUnique) {
        throw new ZSAError("ERROR", "Could not generate a unique slug for the team");
      }

      // Update team with new slug
      await db.update(teamTable)
        .set({
          ...data,
          slug: newSlug,
        })
        .where(eq(teamTable.id, teamId));

      return { ...data, slug: newSlug };
    }
  }

  // Update team without changing slug
  await db.update(teamTable)
    .set(data)
    .where(eq(teamTable.id, teamId));

  return data;
}

/**
 * Delete a team
 */
export async function deleteTeam(teamId: string) {
  // Check if user has permission to delete team
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.DELETE_TEAM);

  const db = getDB();

  // Get all user IDs from the team memberships to update their sessions later
  const memberships = await db.query.teamMembershipTable.findMany({
    where: eq(teamMembershipTable.teamId, teamId),
    columns: {
      userId: true,
    },
  });

  const userIds = [...new Set(memberships.map(m => m.userId))];

  // Delete team and related data
  // Note: In a real implementation, we might want to archive the team instead of deleting it
  await db.delete(teamTable).where(eq(teamTable.id, teamId));

  // Update sessions for all affected users
  for (const userId of userIds) {
    await updateAllSessionsOfUser(userId);
  }

  return { success: true };
}

/**
 * Get a team by ID
 */
export async function getTeam(teamId: string) {
  // Check if user is a member of this team
  await requireTeamPermission(teamId, TEAM_PERMISSIONS.ACCESS_DASHBOARD);

  const db = getDB();

  const team = await db.query.teamTable.findFirst({
    where: eq(teamTable.id, teamId),
  });

  if (!team) {
    throw new ZSAError("NOT_FOUND", "Team not found");
  }

  return team;
}

/**
 * Get all teams for current user
 */
export async function getUserTeams() {
  const session = await requireVerifiedEmail();

  if (!session) {
    throw new ZSAError("NOT_AUTHORIZED", "Not authenticated");
  }

  const db = getDB();

  const userTeams = await db.query.teamMembershipTable.findMany({
    where: eq(teamMembershipTable.userId, session.userId),
    with: {
      team: true,
    },
  });

  // This function doesn't enforce the MAX_TEAMS_JOINED_PER_USER limit directly
  // since it's just retrieving teams, but we use the constant here to show that
  // we're aware of the limit in the system
  if (userTeams.length > MAX_TEAMS_JOINED_PER_USER) {
    console.warn(`User ${session.userId} has exceeded the maximum teams limit: ${userTeams.length}/${MAX_TEAMS_JOINED_PER_USER}`);
  }

  return userTeams.map(membership => membership.team);
}

================
File: src/server/workout-results.ts
================
import "server-only";
import { getDB } from "@/db";
import { results, sets } from "@/db/schema";
import { eq, and } from "drizzle-orm";
import type { WorkoutResult, ResultSet } from "@/types";

/**
 * Get workout results by workout ID and user ID
 */
export async function getWorkoutResultsByWorkoutAndUser(
  workoutId: string,
  userId: string
): Promise<WorkoutResult[]> {
  const db = getDB();
  console.log(
    `Fetching workout results for workoutId: ${workoutId}, userId: ${userId}`
  );
  try {
    const workoutResultsData = await db
      .select()
      .from(results)
      .where(
        and(
          eq(results.workoutId, workoutId),
          eq(results.userId, userId),
          eq(results.type, "wod")
        )
      )
      .orderBy(results.date);
    console.log(`Found ${workoutResultsData.length} results.`);
    return workoutResultsData;
  } catch (error) {
    console.error("Error fetching workout results:", error);
    return [];
  }
}

/**
 * Get result sets by result ID
 */
export async function getResultSetsById(
  resultId: string
): Promise<ResultSet[]> {
  const db = getDB();
  console.log(`Fetching sets for resultId: ${resultId}`);
  try {
    const setDetails = await db
      .select()
      .from(sets)
      .where(eq(sets.resultId, resultId))
      .orderBy(sets.setNumber);
    console.log(`Found ${setDetails.length} sets for resultId ${resultId}.`);
    return setDetails;
  } catch (error) {
    console.error(`Error fetching sets for resultId ${resultId}:`, error);
    return [];
  }
}

================
File: src/db/migrations/meta/_journal.json
================
{
  "version": "7",
  "dialect": "sqlite",
  "entries": [
    {
      "idx": 0,
      "version": "6",
      "when": 1736714082945,
      "tag": "0000_init",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "6",
      "when": 1736742030040,
      "tag": "0001_add_emailVerified",
      "breakpoints": true
    },
    {
      "idx": 2,
      "version": "6",
      "when": 1737313614639,
      "tag": "0002_add_google_sso",
      "breakpoints": true
    },
    {
      "idx": 3,
      "version": "6",
      "when": 1737673858119,
      "tag": "0003_add_google_sso",
      "breakpoints": true
    },
    {
      "idx": 4,
      "version": "6",
      "when": 1738522913553,
      "tag": "0004_add_passkey_credentials",
      "breakpoints": true
    },
    {
      "idx": 5,
      "version": "6",
      "when": 1742847210932,
      "tag": "0005_add_opennext_cache_tables",
      "breakpoints": true
    },
    {
      "idx": 6,
      "version": "6",
      "when": 1742857278889,
      "tag": "0006_add_credit_billing_system",
      "breakpoints": true
    },
    {
      "idx": 7,
      "version": "6",
      "when": 1743721891587,
      "tag": "0007_add_update_counter_and_payment_intent_id",
      "breakpoints": true
    },
    {
      "idx": 8,
      "version": "6",
      "when": 1747391678728,
      "tag": "0008_add_multi_tenancy",
      "breakpoints": true
    },
    {
      "idx": 9,
      "version": "6",
      "when": 1748636693479,
      "tag": "0009_add_spicy_tables",
      "breakpoints": true
    },
    {
      "idx": 10,
      "version": "6",
      "when": 1749058975613,
      "tag": "0010_add_notes_to_sets",
      "breakpoints": true
    }
  ]
}

================
File: src/server/movements.ts
================
import "server-only";
import { getDB } from "@/db";
import { MOVEMENT_TYPE_VALUES, movements } from "@/db/schema";
import { requireVerifiedEmail } from "@/utils/auth";
import { ZSAError } from "zsa";
import { z } from "zod";
import { revalidatePath } from "next/cache";
import { eq, inArray } from "drizzle-orm";
import { workoutMovements, workoutTags, workouts, tags } from "@/db/schema";

export const VALID_MOVEMENT_TYPES = movements.type;

const MOVEMENT_TYPE_SCHEMA = z.enum(MOVEMENT_TYPE_VALUES);

/**
 * Get all movements available in the system
 */
export async function getAllMovements(db: ReturnType<typeof getDB>) {
  const session = await requireVerifiedEmail();

  if (!session) {
    throw new ZSAError("NOT_AUTHORIZED", "Not authenticated");
  }

  const allMovements = await db.select().from(movements);

  return allMovements;
}

/**
 * Get a single movement by ID
 */
export async function getMovementById(id: string) {
  const db = getDB();

  const movement = await db
    .select()
    .from(movements)
    .where(eq(movements.id, id))
    .get();

  return movement;
}

/**
 * Get all workouts that include a specific movement
 */
export async function getWorkoutsByMovementId(movementId: string) {
  const db = getDB();

  // Get workout IDs that include this movement
  const workoutMovementRows = await db
    .select()
    .from(workoutMovements)
    .where(eq(workoutMovements.movementId, movementId));

  const workoutIds = workoutMovementRows
    .map((wm) => wm.workoutId)
    .filter((id): id is string => id !== null);

  if (workoutIds.length === 0) {
    return [];
  }

  // Get the actual workouts
  const workoutsData = await db
    .select()
    .from(workouts)
    .where(inArray(workouts.id, workoutIds));

  // Get tags for these workouts
  const workoutTagsData = await db
    .select({
      workoutId: workoutTags.workoutId,
      tagId: tags.id,
      tagName: tags.name,
    })
    .from(workoutTags)
    .innerJoin(tags, eq(workoutTags.tagId, tags.id))
    .where(inArray(workoutTags.workoutId, workoutIds));

  const tagsByWorkoutId = new Map<string, Array<{ id: string; name: string }>>();
  for (const item of workoutTagsData) {
    if (!tagsByWorkoutId.has(item.workoutId)) {
      tagsByWorkoutId.set(item.workoutId, []);
    }
    tagsByWorkoutId.get(item.workoutId)!.push({
      id: item.tagId,
      name: item.tagName,
    });
  }

  // Get movements for these workouts
  const allWorkoutMovementsData = await db
    .select({
      workoutId: workoutMovements.workoutId,
      movementId: movements.id,
      movementName: movements.name,
      movementType: movements.type,
    })
    .from(workoutMovements)
    .innerJoin(movements, eq(workoutMovements.movementId, movements.id))
    .where(inArray(workoutMovements.workoutId, workoutIds));

  const movementsByWorkoutId = new Map<string, Array<{ id: string; name: string; type: "weightlifting" | "gymnastic" | "monostructural" }>>();
  for (const item of allWorkoutMovementsData) {
    if (item.workoutId && !movementsByWorkoutId.has(item.workoutId)) {
      movementsByWorkoutId.set(item.workoutId, []);
    }
    if (item.workoutId) {
      movementsByWorkoutId.get(item.workoutId)!.push({
        id: item.movementId,
        name: item.movementName,
        type: item.movementType,
      });
    }
  }

  // Compose final structure
  return workoutsData.map((w) => ({
    ...w,
    tags: tagsByWorkoutId.get(w.id) || [],
    movements: movementsByWorkoutId.get(w.id) || [],
  }));
}

// Create a new movement
export async function createMovement(db: ReturnType<typeof getDB>, data: {
  name: string;
  type: string;
  // userId is not in the current schema for movements table
  userId?: string;
}) {
  console.log("[server/functions/movement] createMovement called with data:", data);
  const { name, type: rawType } = data;

  const lowerCaseType = rawType.toLowerCase();

  const parseResult = MOVEMENT_TYPE_SCHEMA.safeParse(lowerCaseType);
  if (!parseResult.success) {
    const allowed = MOVEMENT_TYPE_SCHEMA.options.join(", ");
    const errorMessage = `Invalid movement type: '${lowerCaseType}'. Must be one of: ${allowed}.`;
    console.error(`[server/functions/movement] ${errorMessage}`);
    throw new Error(errorMessage);
  }

  const movementType = parseResult.data;

  if (!name) {
    // type is already validated by implication above
    console.error("[server/functions/movement] Name is required.");
    throw new Error("Movement name is required.");
  }

  const movementId = crypto.randomUUID();
  console.log(`[server/functions/movement] Generated movementId: ${movementId}`);

  try {
    await db.insert(movements).values({
      id: movementId,
      name,
      type: movementType,
    });
    console.log(`[server/functions/movement] Movement created successfully: ${movementId}`);

    revalidatePath("/movements");
    revalidatePath("/"); // Revalidate home page if it lists movements or related data
    console.log("[server/functions/movement] Revalidated paths: /movements, /");

    // Return the created movement or its ID, could be useful for the client
    // For now, the action in page.tsx doesn't expect a return value for redirection
    return { id: movementId, name, movementType };
  } catch (error) {
    console.error(`[server/functions/movement] Error creating movement '${name}':`, error);
    // Consider more specific error messages based on error type
    throw new Error("Failed to create movement in the database.");
  }
}

================
File: src/db/schema.ts
================
import { sqliteTable, integer, text, index } from "drizzle-orm/sqlite-core";
import { relations, sql } from "drizzle-orm";
import { type InferSelectModel } from "drizzle-orm";

import { createId } from "@paralleldrive/cuid2";
import { Prettify } from "@/lib/utils";

export const ROLES_ENUM = {
  ADMIN: "admin",
  USER: "user",
} as const;

const roleTuple = Object.values(ROLES_ENUM) as [string, ...string[]];

const commonColumns = {
  createdAt: integer({
    mode: "timestamp",
  })
    .$defaultFn(() => new Date())
    .notNull(),
  updatedAt: integer({
    mode: "timestamp",
  })
    .$onUpdateFn(() => new Date())
    .notNull(),
  updateCounter: integer()
    .default(0)
    .$onUpdate(() => sql`updateCounter + 1`),
};

export const userTable = sqliteTable(
  "user",
  {
    ...commonColumns,
    id: text()
      .primaryKey()
      .$defaultFn(() => `usr_${createId()}`)
      .notNull(),
    firstName: text({
      length: 255,
    }),
    lastName: text({
      length: 255,
    }),
    email: text({
      length: 255,
    }).unique(),
    passwordHash: text(),
    role: text({
      enum: roleTuple,
    })
      .default(ROLES_ENUM.USER)
      .notNull(),
    emailVerified: integer({
      mode: "timestamp",
    }),
    signUpIpAddress: text({
      length: 100,
    }),
    googleAccountId: text({
      length: 255,
    }),
    /**
     * This can either be an absolute or relative path to an image
     */
    avatar: text({
      length: 600,
    }),
    // Credit system fields
    currentCredits: integer().default(0).notNull(),
    lastCreditRefreshAt: integer({
      mode: "timestamp",
    }),
  },
  (table) => [
    index("email_idx").on(table.email),
    index("google_account_id_idx").on(table.googleAccountId),
    index("role_idx").on(table.role),
  ]
);

export const passKeyCredentialTable = sqliteTable(
  "passkey_credential",
  {
    ...commonColumns,
    id: text()
      .primaryKey()
      .$defaultFn(() => `pkey_${createId()}`)
      .notNull(),
    userId: text()
      .notNull()
      .references(() => userTable.id),
    credentialId: text({
      length: 255,
    })
      .notNull()
      .unique(),
    credentialPublicKey: text({
      length: 255,
    }).notNull(),
    counter: integer().notNull(),
    // Optional array of AuthenticatorTransport as JSON string
    transports: text({
      length: 255,
    }),
    // Authenticator Attestation GUID. We use this to identify the device/authenticator app that created the passkey
    aaguid: text({
      length: 255,
    }),
    // The user agent of the device that created the passkey
    userAgent: text({
      length: 255,
    }),
    // The IP address that created the passkey
    ipAddress: text({
      length: 100,
    }),
  },
  (table) => [
    index("user_id_idx").on(table.userId),
    index("credential_id_idx").on(table.credentialId),
  ]
);

// Credit transaction types
export const CREDIT_TRANSACTION_TYPE = {
  PURCHASE: "PURCHASE",
  USAGE: "USAGE",
  MONTHLY_REFRESH: "MONTHLY_REFRESH",
} as const;

export const creditTransactionTypeTuple = Object.values(
  CREDIT_TRANSACTION_TYPE
) as [string, ...string[]];

export const creditTransactionTable = sqliteTable(
  "credit_transaction",
  {
    ...commonColumns,
    id: text()
      .primaryKey()
      .$defaultFn(() => `ctxn_${createId()}`)
      .notNull(),
    userId: text()
      .notNull()
      .references(() => userTable.id),
    amount: integer().notNull(),
    // Track how many credits are still available from this transaction
    remainingAmount: integer().default(0).notNull(),
    type: text({
      enum: creditTransactionTypeTuple,
    }).notNull(),
    description: text({
      length: 255,
    }).notNull(),
    expirationDate: integer({
      mode: "timestamp",
    }),
    expirationDateProcessedAt: integer({
      mode: "timestamp",
    }),
    paymentIntentId: text({
      length: 255,
    }),
  },
  (table) => [
    index("credit_transaction_user_id_idx").on(table.userId),
    index("credit_transaction_type_idx").on(table.type),
    index("credit_transaction_created_at_idx").on(table.createdAt),
    index("credit_transaction_expiration_date_idx").on(table.expirationDate),
    index("credit_transaction_payment_intent_id_idx").on(table.paymentIntentId),
  ]
);

// Define item types that can be purchased
export const PURCHASABLE_ITEM_TYPE = {
  COMPONENT: "COMPONENT",
  // Add more types in the future (e.g., TEMPLATE, PLUGIN, etc.)
} as const;

export const purchasableItemTypeTuple = Object.values(
  PURCHASABLE_ITEM_TYPE
) as [string, ...string[]];

export const purchasedItemsTable = sqliteTable(
  "purchased_item",
  {
    ...commonColumns,
    id: text()
      .primaryKey()
      .$defaultFn(() => `pitem_${createId()}`)
      .notNull(),
    userId: text()
      .notNull()
      .references(() => userTable.id),
    // The type of item (e.g., COMPONENT, TEMPLATE, etc.)
    itemType: text({
      enum: purchasableItemTypeTuple,
    }).notNull(),
    // The ID of the item within its type (e.g., componentId)
    itemId: text().notNull(),
    purchasedAt: integer({
      mode: "timestamp",
    })
      .$defaultFn(() => new Date())
      .notNull(),
  },
  (table) => [
    index("purchased_item_user_id_idx").on(table.userId),
    index("purchased_item_type_idx").on(table.itemType),
    // Composite index for checking if a user owns a specific item of a specific type
    index("purchased_item_user_item_idx").on(
      table.userId,
      table.itemType,
      table.itemId
    ),
  ]
);

// System-defined roles - these are always available
export const SYSTEM_ROLES_ENUM = {
  OWNER: "owner",
  ADMIN: "admin",
  MEMBER: "member",
  GUEST: "guest",
} as const;

export const systemRoleTuple = Object.values(SYSTEM_ROLES_ENUM) as [
  string,
  ...string[]
];

// Define available permissions
export const TEAM_PERMISSIONS = {
  // Resource access
  ACCESS_DASHBOARD: "access_dashboard",
  ACCESS_BILLING: "access_billing",

  // User management
  INVITE_MEMBERS: "invite_members",
  REMOVE_MEMBERS: "remove_members",
  CHANGE_MEMBER_ROLES: "change_member_roles",

  // Team management
  EDIT_TEAM_SETTINGS: "edit_team_settings",
  DELETE_TEAM: "delete_team",

  // Role management
  CREATE_ROLES: "create_roles",
  EDIT_ROLES: "edit_roles",
  DELETE_ROLES: "delete_roles",
  ASSIGN_ROLES: "assign_roles",

  // Content permissions
  CREATE_COMPONENTS: "create_components",
  EDIT_COMPONENTS: "edit_components",
  DELETE_COMPONENTS: "delete_components",

  // Add more as needed
} as const;

// Team table
export const teamTable = sqliteTable(
  "team",
  {
    ...commonColumns,
    id: text()
      .primaryKey()
      .$defaultFn(() => `team_${createId()}`)
      .notNull(),
    name: text({ length: 255 }).notNull(),
    slug: text({ length: 255 }).notNull().unique(),
    description: text({ length: 1000 }),
    avatarUrl: text({ length: 600 }),
    // Settings could be stored as JSON
    settings: text({ length: 10000 }),
    // Optional billing-related fields
    billingEmail: text({ length: 255 }),
    planId: text({ length: 100 }),
    planExpiresAt: integer({ mode: "timestamp" }),
    creditBalance: integer().default(0).notNull(),
  },
  (table) => [index("team_slug_idx").on(table.slug)]
);

// Team membership table
export const teamMembershipTable = sqliteTable(
  "team_membership",
  {
    ...commonColumns,
    id: text()
      .primaryKey()
      .$defaultFn(() => `tmem_${createId()}`)
      .notNull(),
    teamId: text()
      .notNull()
      .references(() => teamTable.id),
    userId: text()
      .notNull()
      .references(() => userTable.id),
    // This can be either a system role or a custom role ID
    roleId: text().notNull(),
    // Flag to indicate if this is a system role
    isSystemRole: integer().default(1).notNull(),
    invitedBy: text().references(() => userTable.id),
    invitedAt: integer({ mode: "timestamp" }),
    joinedAt: integer({ mode: "timestamp" }),
    expiresAt: integer({ mode: "timestamp" }),
    isActive: integer().default(1).notNull(),
  },
  (table) => [
    index("team_membership_team_id_idx").on(table.teamId),
    index("team_membership_user_id_idx").on(table.userId),
    // Instead of unique() which causes linter errors, we'll create a unique constraint on columns
    index("team_membership_unique_idx").on(table.teamId, table.userId),
  ]
);

// Team role table
export const teamRoleTable = sqliteTable(
  "team_role",
  {
    ...commonColumns,
    id: text()
      .primaryKey()
      .$defaultFn(() => `trole_${createId()}`)
      .notNull(),
    teamId: text()
      .notNull()
      .references(() => teamTable.id),
    name: text({ length: 255 }).notNull(),
    description: text({ length: 1000 }),
    // Store permissions as a JSON array of permission keys
    permissions: text({ mode: "json" }).notNull().$type<string[]>(),
    // A JSON field for storing UI-specific settings like color, icon, etc.
    metadata: text({ length: 5000 }),
    // Optional flag to mark some roles as non-editable
    isEditable: integer().default(1).notNull(),
  },
  (table) => [
    index("team_role_team_id_idx").on(table.teamId),
    // Instead of unique() which causes linter errors, we'll create a unique constraint on columns
    index("team_role_name_unique_idx").on(table.teamId, table.name),
  ]
);

// Team invitation table
export const teamInvitationTable = sqliteTable(
  "team_invitation",
  {
    ...commonColumns,
    id: text()
      .primaryKey()
      .$defaultFn(() => `tinv_${createId()}`)
      .notNull(),
    teamId: text()
      .notNull()
      .references(() => teamTable.id),
    email: text({ length: 255 }).notNull(),
    // This can be either a system role or a custom role ID
    roleId: text().notNull(),
    // Flag to indicate if this is a system role
    isSystemRole: integer().default(1).notNull(),
    token: text({ length: 255 }).notNull().unique(),
    invitedBy: text()
      .notNull()
      .references(() => userTable.id),
    expiresAt: integer({ mode: "timestamp" }).notNull(),
    acceptedAt: integer({ mode: "timestamp" }),
    acceptedBy: text().references(() => userTable.id),
  },
  (table) => [
    index("team_invitation_team_id_idx").on(table.teamId),
    index("team_invitation_email_idx").on(table.email),
    index("team_invitation_token_idx").on(table.token),
  ]
);

export const teamRelations = relations(teamTable, ({ many }) => ({
  memberships: many(teamMembershipTable),
  invitations: many(teamInvitationTable),
  roles: many(teamRoleTable),
}));

export const teamRoleRelations = relations(teamRoleTable, ({ one }) => ({
  team: one(teamTable, {
    fields: [teamRoleTable.teamId],
    references: [teamTable.id],
  }),
}));

export const teamMembershipRelations = relations(
  teamMembershipTable,
  ({ one }) => ({
    team: one(teamTable, {
      fields: [teamMembershipTable.teamId],
      references: [teamTable.id],
    }),
    user: one(userTable, {
      relationName: "member",
      fields: [teamMembershipTable.userId],
      references: [userTable.id],
    }),
    invitedByUser: one(userTable, {
      relationName: "inviter",
      fields: [teamMembershipTable.invitedBy],
      references: [userTable.id],
    }),
  })
);

export const teamInvitationRelations = relations(
  teamInvitationTable,
  ({ one }) => ({
    team: one(teamTable, {
      fields: [teamInvitationTable.teamId],
      references: [teamTable.id],
    }),
    invitedByUser: one(userTable, {
      relationName: "inviter",
      fields: [teamInvitationTable.invitedBy],
      references: [userTable.id],
    }),
    acceptedByUser: one(userTable, {
      relationName: "acceptor",
      fields: [teamInvitationTable.acceptedBy],
      references: [userTable.id],
    }),
  })
);

export const creditTransactionRelations = relations(
  creditTransactionTable,
  ({ one }) => ({
    user: one(userTable, {
      fields: [creditTransactionTable.userId],
      references: [userTable.id],
    }),
  })
);

export const purchasedItemsRelations = relations(
  purchasedItemsTable,
  ({ one }) => ({
    user: one(userTable, {
      fields: [purchasedItemsTable.userId],
      references: [userTable.id],
    }),
  })
);

export const userRelations = relations(userTable, ({ many }) => ({
  passkeys: many(passKeyCredentialTable),
  creditTransactions: many(creditTransactionTable),
  purchasedItems: many(purchasedItemsTable),
  teamMemberships: many(teamMembershipTable, {
    relationName: "member",
  }),
  invitedTeamMemberships: many(teamMembershipTable, {
    relationName: "inviter",
  }),
  invitedTeamInvitations: many(teamInvitationTable, {
    relationName: "inviter",
  }),
  acceptedTeamInvitations: many(teamInvitationTable, {
    relationName: "acceptor",
  }),
}));

export const passKeyCredentialRelations = relations(
  passKeyCredentialTable,
  ({ one }) => ({
    user: one(userTable, {
      fields: [passKeyCredentialTable.userId],
      references: [userTable.id],
    }),
  })
);


export const MOVEMENT_TYPE_VALUES = ["weightlifting", "gymnastic", "monostructural"] as const;
export const movements = sqliteTable("movements", {
  ...commonColumns,
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  type: text("type", {
    enum: ["weightlifting", "gymnastic", "monostructural"],
  }).notNull(),
});

// Tags table (new)
export const tags = sqliteTable("spicy_tags", {
  ...commonColumns,
  id: text("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// Workout Tags junction table (new)
export const workoutTags = sqliteTable("workout_tags", {
  ...commonColumns,
  id: text("id").primaryKey(),
  workoutId: text("workout_id")
    .references(() => workouts.id)
    .notNull(),
  tagId: text("tag_id")
    .references(() => tags.id)
    .notNull(),
});

// Workouts table (with relation to tags)
export const workouts = sqliteTable("workouts", {
  ...commonColumns,
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  scope: text("scope", {
    enum: ["private", "public"],
  })
    .default("private")
    .notNull(),
  scheme: text("scheme", {
    enum: [
      "time",
      "time-with-cap",
      "pass-fail",
      "rounds-reps",
      "reps",
      "emom",
      "load",
      "calories",
      "meters",
      "feet",
      "points",
    ],
  }).notNull(),
  repsPerRound: integer("reps_per_round"),
  roundsToScore: integer("rounds_to_score").default(1),
  userId: text("user_id").references(() => userTable.id),
  sugarId: text("sugar_id"),
  tiebreakScheme: text("tiebreak_scheme", { enum: ["time", "reps"] }),
  secondaryScheme: text("secondary_scheme", {
    enum: [
      "time",
      "pass-fail",
      "rounds-reps",
      "reps",
      "emom",
      "load",
      "calories",
      "meters",
      "feet",
      "points",
    ],
  }),
});

// Workout Movements junction table (no changes)
export const workoutMovements = sqliteTable("workout_movements", {
  ...commonColumns,
  id: text("id").primaryKey(),
  workoutId: text("workout_id").references(() => workouts.id),
  movementId: text("movement_id").references(() => movements.id),
});

// Results base table (consolidated)
export const results = sqliteTable("results", {
  ...commonColumns,
  id: text("id").primaryKey(),
  userId: text("user_id")
    .references(() => userTable.id)
    .notNull(),
  date: integer("date", { mode: "timestamp" }).notNull(),
  workoutId: text("workout_id").references(() => workouts.id), // Optional, for WOD results
  type: text("type", {
    enum: ["wod", "strength", "monostructural"],
  }).notNull(),
  notes: text("notes"),

  // WOD specific results
  scale: text("scale", { enum: ["rx", "scaled", "rx+"] }),
  wodScore: text("wod_score"), // e.g., "3:15", "10 rounds + 5 reps"

  // Strength specific results
  setCount: integer("set_count"),

  // Monostructural specific results
  distance: integer("distance"),
  time: integer("time"),
});

// Sets table (unified for all result types)
export const sets = sqliteTable("sets", {
  ...commonColumns,
  id: text("id").primaryKey(),
  resultId: text("result_id")
    .references(() => results.id)
    .notNull(),
  setNumber: integer("set_number").notNull(),
  notes: text("notes"),

  // Generic set data - only one of these will typically be populated
  reps: integer("reps"),
  weight: integer("weight"),
  status: text("status", { enum: ["pass", "fail"] }),
  distance: integer("distance"),
  time: integer("time"),
  score: integer("score"), // For sets within a WOD (e.g., rounds completed in an AMRAP)
});

export type User = Prettify<InferSelectModel<typeof userTable>>;
export type PassKeyCredential = Prettify<
  InferSelectModel<typeof passKeyCredentialTable>
>;
export type CreditTransaction = Prettify<
  InferSelectModel<typeof creditTransactionTable>
>;
export type PurchasedItem = Prettify<
  InferSelectModel<typeof purchasedItemsTable>
>;
export type Team = Prettify<InferSelectModel<typeof teamTable>>;
export type TeamMembership = Prettify<
  InferSelectModel<typeof teamMembershipTable>
>;
export type TeamRole = Prettify<InferSelectModel<typeof teamRoleTable>>;
export type TeamInvitation = Prettify<
  InferSelectModel<typeof teamInvitationTable>
>;
export type Workout = Prettify<InferSelectModel<typeof workouts>>;
export type Movement = Prettify<InferSelectModel<typeof movements>>;
export type Tag = Prettify<InferSelectModel<typeof tags>>;
export type WorkoutTag = Prettify<InferSelectModel<typeof workoutTags>>;
export type Result = Prettify<InferSelectModel<typeof results>>;
export type Set = Prettify<InferSelectModel<typeof sets>>;
export type WorkoutMovement = Prettify<
  InferSelectModel<typeof workoutMovements>
>;

================
File: src/server/workouts.ts
================
import "server-only";
import { getDB } from "@/db";
import {
  workouts,
  workoutTags,
  tags,
  workoutMovements,
  movements,
  results,
} from "@/db/schema";
import { requireVerifiedEmail } from "@/utils/auth";
import { ZSAError } from "zsa";
import { eq, or, and, inArray, gte, lt, isNotNull } from "drizzle-orm";
import { createId } from "@paralleldrive/cuid2";
import type { Workout } from "@/db/schema";

/**
 * Helper function to fetch tags by workout IDs
 */
async function fetchTagsByWorkoutId(
  db: ReturnType<typeof getDB>,
  workoutIds: string[]
): Promise<Map<string, Array<{ id: string; name: string }>>> {
  if (workoutIds.length === 0) return new Map();

  const workoutTagsData = await db
    .select({
      workoutId: workoutTags.workoutId,
      tagId: tags.id,
      tagName: tags.name,
    })
    .from(workoutTags)
    .innerJoin(tags, eq(workoutTags.tagId, tags.id))
    .where(inArray(workoutTags.workoutId, workoutIds));

  const tagsByWorkoutId = new Map<
    string,
    Array<{ id: string; name: string }>
  >();

  for (const item of workoutTagsData) {
    if (!tagsByWorkoutId.has(item.workoutId)) {
      tagsByWorkoutId.set(item.workoutId, []);
    }
    tagsByWorkoutId.get(item.workoutId)!.push({
      id: item.tagId,
      name: item.tagName,
    });
  }

  return tagsByWorkoutId;
}

/**
 * Helper function to fetch movements by workout IDs
 */
async function fetchMovementsByWorkoutId(
  db: ReturnType<typeof getDB>,
  workoutIds: string[]
): Promise<Map<string, Array<{ id: string; name: string; type: string }>>> {
  if (workoutIds.length === 0) return new Map();

  const workoutMovementsData = await db
    .select({
      workoutId: workoutMovements.workoutId,
      movementId: movements.id,
      movementName: movements.name,
      movementType: movements.type,
    })
    .from(workoutMovements)
    .innerJoin(movements, eq(workoutMovements.movementId, movements.id))
    .where(inArray(workoutMovements.workoutId, workoutIds));

  const movementsByWorkoutId = new Map<
    string,
    Array<{ id: string; name: string; type: string }>
  >();

  for (const item of workoutMovementsData) {
    if (!movementsByWorkoutId.has(item?.workoutId || "")) {
      movementsByWorkoutId.set(item?.workoutId || "", []);
    }
    movementsByWorkoutId.get(item?.workoutId || "")!.push({
      id: item.movementId,
      name: item.movementName,
      type: item.movementType,
    });
  }

  return movementsByWorkoutId;
}

/**
 * Helper function to fetch today's results by workout IDs
 */
async function fetchTodaysResultsByWorkoutId(
  db: ReturnType<typeof getDB>,
  userId: string,
  workoutIds: string[]
): Promise<Map<string, Array<(typeof todaysResults)[0]>>> {
  if (workoutIds.length === 0) return new Map();

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);

  const todaysResults = await db
    .select()
    .from(results)
    .where(
      and(
        eq(results.userId, userId),
        isNotNull(results.workoutId),
        inArray(results.workoutId, workoutIds),
        gte(results.date, today),
        lt(results.date, tomorrow)
      )
    );

  const resultsByWorkoutId = new Map<
    string,
    Array<(typeof todaysResults)[0]>
  >();

  for (const result of todaysResults) {
    const workoutId = result.workoutId!;

    if (!resultsByWorkoutId.has(workoutId)) {
      resultsByWorkoutId.set(workoutId, []);
    }
    resultsByWorkoutId.get(workoutId)!.push(result);
  }

  return resultsByWorkoutId;
}

/**
 * Get all workouts for the current user (public workouts + user's private workouts)
 */
export async function getUserWorkouts({ userId }: { userId: string }) {
  const db = getDB();

  // Base workouts and ids
  const allWorkouts = await db
    .select()
    .from(workouts)
    .where(or(eq(workouts.scope, "public"), eq(workouts.userId, userId)));

  const workoutIds = allWorkouts.map((w) => w.id);

  // Fetch related data in parallel
  const [tagsByWorkoutId, movementsByWorkoutId, resultsByWorkoutId] =
    await Promise.all([
      fetchTagsByWorkoutId(db, workoutIds),
      fetchMovementsByWorkoutId(db, workoutIds),
      fetchTodaysResultsByWorkoutId(db, userId, workoutIds),
    ]);

  // Compose final structure
  return allWorkouts.map((w) => ({
    ...w,
    tags: tagsByWorkoutId.get(w.id) || [],
    movements: movementsByWorkoutId.get(w.id) || [],
    resultsToday: resultsByWorkoutId.get(w.id) || [],
  }));
}

/**
 * Create a new workout with tags and movements
 */
export async function createWorkout({
  workout,
  tagIds,
  movementIds,
  userId,
}: {
  workout: Omit<Workout, "id" | "updatedAt" | "updateCounter" | "userId"> & {
    createdAt: Date;
  };
  tagIds: string[];
  movementIds: string[];
  userId: string;
}) {
  const db = getDB();

  // Create the workout first
  const newWorkout = await db
    .insert(workouts)
    .values({
      id: `workout_${createId()}`,
      name: workout.name,
      description: workout.description,
      scheme: workout.scheme,
      scope: workout.scope,
      repsPerRound: workout.repsPerRound,
      roundsToScore: workout.roundsToScore,
      sugarId: workout.sugarId,
      tiebreakScheme: workout.tiebreakScheme,
      secondaryScheme: workout.secondaryScheme,
      userId,
      createdAt: workout.createdAt,
      updatedAt: new Date(),
      updateCounter: 0,
    })
    .returning()
    .get();

  // Insert workout-tag relationships
  if (tagIds.length > 0) {
    await db.insert(workoutTags).values(
      tagIds.map((tagId) => ({
        id: `workout_tag_${createId()}`,
        workoutId: newWorkout.id,
        tagId,
      }))
    );
  }

  // Insert workout-movement relationships
  if (movementIds.length > 0) {
    await db.insert(workoutMovements).values(
      movementIds.map((movementId) => ({
        id: `workout_movement_${createId()}`,
        workoutId: newWorkout.id,
        movementId,
      }))
    );
  }

  return newWorkout;
}

/**
 * Get a single workout by ID with its tags and movements
 */
export async function getWorkoutById(id: string) {
  const db = getDB();

  const workout = await db
    .select()
    .from(workouts)
    .where(eq(workouts.id, id))
    .get();

  if (!workout) return null;

  const workoutTagRows = await db
    .select()
    .from(workoutTags)
    .where(eq(workoutTags.workoutId, id));
  const tagIds = workoutTagRows.map((wt) => wt.tagId);
  const tagObjs = tagIds.length
    ? await db.select().from(tags).where(inArray(tags.id, tagIds))
    : [];

  const workoutMovementRows = await db
    .select()
    .from(workoutMovements)
    .where(eq(workoutMovements.workoutId, id));
  const movementIds = workoutMovementRows
    .map((wm) => wm.movementId)
    .filter((id): id is string => id !== null);
  const movementObjs = movementIds.length
    ? await db
        .select()
        .from(movements)
        .where(inArray(movements.id, movementIds))
    : [];

  return {
    ...workout,
    tags: tagObjs,
    movements: movementObjs,
  };
}

/**
 * Update a workout with tags and movements
 */
export async function updateWorkout({
  id,
  workout,
  tagIds,
  movementIds,
}: {
  id: string;
  workout: Partial<
    Pick<
      Workout,
      | "name"
      | "description"
      | "scheme"
      | "scope"
      | "repsPerRound"
      | "roundsToScore"
    >
  >;
  tagIds: string[];
  movementIds: string[];
}) {
  const db = getDB();

  await db
    .update(workouts)
    .set({
      ...workout,
      updatedAt: new Date(),
    })
    .where(eq(workouts.id, id));

  await db.delete(workoutTags).where(eq(workoutTags.workoutId, id));
  await db.delete(workoutMovements).where(eq(workoutMovements.workoutId, id));

  if (tagIds.length) {
    await db.insert(workoutTags).values(
      tagIds.map((tagId) => ({
        id: `workout_tag_${createId()}`,
        workoutId: id,
        tagId,
      }))
    );
  }
  if (movementIds.length) {
    await db.insert(workoutMovements).values(
      movementIds.map((movementId) => ({
        id: `workout_movement_${createId()}`,
        workoutId: id,
        movementId,
      }))
    );
  }
}




================================================================
End of Codebase
================================================================
